<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArchiSchedule</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom Scrollbar for sleek UI */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .dark ::-webkit-scrollbar-thumb {
            background: #475569;
        }

        .dark ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* Link line fade transitions */
        .link-svg-fade {
            transition: opacity 0.25s ease;
        }

        .link-svg-fade.visible {
            opacity: 1;
        }

        .link-svg-fade.hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* Hover effect: invisible hit area changes sibling visible path color */
        .link-hit-group:hover .link-visible-path {
            stroke: #f87171 !important;
        }

        .dark .link-hit-group:hover .link-visible-path {
            stroke: #ef4444 !important;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef, useCallback } = React;

        // --- Icon Wrapper ---
        const Icon = ({ name, className, ...rest }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (ref.current) {
                    ref.current.innerHTML = `<i data-lucide="${name}" class="${className || ''}"></i>`;
                    window.lucide.createIcons({ root: ref.current });
                }
            }, [name, className]);
            return <span ref={ref} {...rest} style={{ display: 'contents' }} />;
        };

        const ChevronRight = (p) => <Icon name="chevron-right" {...p} />;
        const ChevronDown = (p) => <Icon name="chevron-down" {...p} />;
        const Plus = (p) => <Icon name="plus" {...p} />;
        const Trash2 = (p) => <Icon name="trash-2" {...p} />;
        const Filter = (p) => <Icon name="filter" {...p} />;
        const Flag = (p) => <Icon name="flag" {...p} />;
        const Briefcase = (p) => <Icon name="briefcase" {...p} />;
        const AlertCircle = (p) => <Icon name="alert-circle" {...p} />;
        const CalendarDays = (p) => <Icon name="calendar-days" {...p} />;
        const BriefcaseBusiness = (p) => <Icon name="briefcase-business" {...p} />;
        const Moon = (p) => <Icon name="moon" {...p} />;
        const Sun = (p) => <Icon name="sun" {...p} />;
        const Download = (p) => <Icon name="download" {...p} />;
        const Copy = (p) => <Icon name="copy" {...p} />;
        const Folder = (p) => <Icon name="folder" {...p} />;
        const FileIcon = (p) => <Icon name="file" {...p} />;
        const X = (p) => <Icon name="x" {...p} />;
        const FileText = (p) => <Icon name="file-text" {...p} />;
        const FileSpreadsheet = (p) => <Icon name="file-spreadsheet" {...p} />;
        const Edit2 = (p) => <Icon name="edit-2" {...p} />;
        const FilePlus = (p) => <Icon name="file-plus" {...p} />;
        const Upload = (p) => <Icon name="upload" {...p} />;
        const Calendar = (p) => <Icon name="calendar" {...p} />;
        const Presentation = (p) => <Icon name="presentation" {...p} />;
        const LayoutDashboard = (p) => <Icon name="layout-dashboard" {...p} />;
        const Loader2 = (p) => <Icon name="loader-2" {...p} />;
        const ListTree = (p) => <Icon name="list-tree" {...p} />;
        const Eye = (p) => <Icon name="eye" {...p} />;

        // --- Date Utilities ---
        const parseDate = (str) => new Date(str + 'T12:00:00Z');
        const isValidDateStr = (str) => { if (!str) return false; return !isNaN(parseDate(str).getTime()); };

        const formatShortDate = (dateStr) => {
            if (!isValidDateStr(dateStr)) return '';
            const d = parseDate(dateStr);
            return `${String(d.getUTCMonth() + 1).padStart(2, '0')}/${String(d.getUTCDate()).padStart(2, '0')}/${String(d.getUTCFullYear()).slice(2)}`;
        };

        const parseShortDate = (str) => {
            if (!str) return '';
            const parts = str.split('/');
            if (parts.length !== 3) return '';
            const [mm, dd, yy] = parts;
            const m = parseInt(mm, 10), d = parseInt(dd, 10), y = parseInt(yy, 10);
            if (isNaN(m) || isNaN(d) || isNaN(y)) return '';
            const result = `${String(y + 2000)}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
            return isValidDateStr(result) ? result : '';
        };

        const formatDayMonth = (dateStr) => {
            if (!isValidDateStr(dateStr)) return '';
            const d = parseDate(dateStr);
            return `${String(d.getUTCMonth() + 1).padStart(2, '0')}/${String(d.getUTCDate()).padStart(2, '0')}`;
        };

        const HOLIDAYS = [
            '2026-01-01', '2026-01-19', '2026-02-16', '2026-05-25', '2026-06-19', '2026-07-03', '2026-09-07', '2026-10-12', '2026-11-11', '2026-11-26', '2026-12-25',
            '2027-01-01', '2027-01-18', '2027-02-15', '2027-05-31', '2027-06-18', '2027-07-05', '2027-09-06', '2027-10-11', '2027-11-11', '2027-11-25', '2027-12-24'
        ];

        const addDays = (dateStr, days) => {
            const d = parseDate(dateStr);
            d.setUTCDate(d.getUTCDate() + parseInt(days, 10));
            return d.toISOString().split('T')[0];
        };

        const diffDays = (startStr, endStr) => {
            const start = parseDate(startStr);
            const end = parseDate(endStr);
            return Math.round((end - start) / (1000 * 60 * 60 * 24));
        };

        const isWeekend = (date) => date.getUTCDay() === 0 || date.getUTCDay() === 6;
        const isHoliday = (dateStr) => HOLIDAYS.includes(dateStr);
        const isNonWorkingDay = (dateStr, type) => {
            if (type === 'Calendar') return false;
            return isWeekend(parseDate(dateStr)) || isHoliday(dateStr);
        };

        const calculateEndDate = (startStr, durationInDays, type) => {
            let dur = Math.max(1, durationInDays);
            if (type === 'Calendar') return addDays(startStr, dur - 1);
            let current = parseDate(startStr);
            let added = 0;
            while (added < dur) {
                const dStr = current.toISOString().split('T')[0];
                if (!isWeekend(current) && !isHoliday(dStr)) added++;
                if (added < dur) current.setUTCDate(current.getUTCDate() + 1);
            }
            return current.toISOString().split('T')[0];
        };

        const getDurationBetweenDates = (startStr, endStr, type) => {
            let current = parseDate(startStr);
            const end = parseDate(endStr);
            if (current > end) return 1;
            let days = 0;
            while (current <= end) {
                const dStr = current.toISOString().split('T')[0];
                if (type === 'Calendar' || (!isWeekend(current) && !isHoliday(dStr))) days++;
                current.setUTCDate(current.getUTCDate() + 1);
            }
            return Math.max(1, days);
        };

        const recalculateSchedule = (currentTasks, type) => {
            let updated = JSON.parse(JSON.stringify(currentTasks));
            let changed = true;
            let iterations = 0;
            while (changed && iterations < 100) {
                changed = false;
                iterations++;
                for (let i = 0; i < updated.length; i++) {
                    let task = updated[i];
                    if (task.deps && task.deps.length > 0) {
                        let maxEndStr = '1970-01-01';
                        task.deps.forEach(depId => {
                            const depTask = updated.find(t => t.id === depId);
                            if (depTask) {
                                let depEnd = calculateEndDate(depTask.start, depTask.duration, type);
                                if (!task.milestone) {
                                    depEnd = addDays(depEnd, 1);
                                    if (type === 'Business') {
                                        while (isNonWorkingDay(depEnd, type)) depEnd = addDays(depEnd, 1);
                                    }
                                }
                                if (depEnd > maxEndStr) maxEndStr = depEnd;
                            }
                        });
                        if (task.start !== maxEndStr) {
                            task.start = maxEndStr;
                            changed = true;
                        }
                    }
                }
            }
            return updated;
        };

        const getEarliestAndLatestDates = (tasks, type) => {
            if (tasks.length === 0) return { start: parseDate(new Date().toISOString().split('T')[0]), end: parseDate(addDays(new Date().toISOString().split('T')[0], 30)) };
            let earliestStr = tasks[0].start;
            let latestStr = calculateEndDate(tasks[0].start, tasks[0].duration, type);
            tasks.forEach(t => {
                if (t.start < earliestStr) earliestStr = t.start;
                const e = calculateEndDate(t.start, t.duration, type);
                if (e > latestStr) latestStr = e;
            });
            const earliest = parseDate(earliestStr);
            const latest = parseDate(latestStr);
            earliest.setUTCDate(earliest.getUTCDate() - 7);
            latest.setUTCDate(latest.getUTCDate() + 21);
            return { start: earliest, end: latest };
        };

        const generateICS = (tasks) => {
            const milestones = tasks.filter(t => t.milestone > 0);
            let ics = 'BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ArchiSchedule//EN\n';
            milestones.forEach(m => {
                const start = m.start.replace(/-/g, '') + 'T090000Z';
                const end = m.start.replace(/-/g, '') + 'T100000Z';
                ics += 'BEGIN:VEVENT\n';
                ics += `DTSTART:${start}\n`;
                ics += `DTEND:${end}\n`;
                ics += `SUMMARY:Milestone: ${m.name}\n`;
                ics += `DESCRIPTION:Phase: ${m.phase}\\nParty: ${m.party}\n`;
                ics += 'END:VEVENT\n';
            });
            ics += 'END:VCALENDAR';
            return ics;
        };

        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) return resolve();
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        };

        const INITIAL_PHASES = ['Pre-Design', 'Schematic Design', 'Design Development', 'Construction Documents', 'Permitting', 'Bidding', 'Construction Admin'];
        const PARTIES = ['Architect', 'Client', 'Structural', 'MEP', 'Civil', 'Landscape', 'Municipality', 'Contractor'];
        const INITIAL_PHASE_COLORS = { 'Pre-Design': '#64748b', 'Schematic Design': '#3b82f6', 'Design Development': '#6366f1', 'Construction Documents': '#7c3aed', 'Permitting': '#f97316', 'Bidding': '#f59e0b', 'Construction Admin': '#059669' };
        const INITIAL_PHASE_PARENTS = {};
        const INITIAL_TASKS = [
            { id: '1', name: 'Project Kickoff', phase: 'Pre-Design', party: 'All', start: '2026-03-02', duration: 1, milestone: 1, deps: [] },
            { id: '2', name: 'Site Survey & Scanning', phase: 'Pre-Design', party: 'Civil', start: '2026-03-03', duration: 10, milestone: 0, deps: ['1'] },
            { id: '3', name: 'Zoning Analysis', phase: 'Pre-Design', party: 'Architect', start: '2026-03-03', duration: 5, milestone: 0, deps: ['1'] },
            { id: '4', name: 'Concept Sketches', phase: 'Schematic Design', party: 'Architect', start: '2026-03-17', duration: 14, milestone: 0, deps: ['2', '3'] },
            { id: '5', name: 'Owner Concept Review', phase: 'Schematic Design', party: 'Client', start: '2026-04-06', duration: 1, milestone: 2, deps: ['4'] },
        ];

        function App() {
            const [viewMode, setViewMode] = useState(() => localStorage.getItem('archiViewMode') || 'Business');
            const durationType = 'Business'; // Core engine always uses Business days to prevent destructive schedule shifts

            const [projects, setProjects] = useState(() => {
                try {
                    const saved = localStorage.getItem('archiScheduleData');
                    if (saved) return JSON.parse(saved);
                } catch (e) { console.error("Load failed", e); }
                return [{
                    id: 'p1', name: 'Sample Architecture Project', clientName: '',
                    versions: [{ id: 'v1', name: 'Base Schedule', tasks: INITIAL_TASKS, phases: INITIAL_PHASES, phaseColors: INITIAL_PHASE_COLORS, phaseParents: INITIAL_PHASE_PARENTS }]
                }];
            });
            const [activeProjectId, setActiveProjectId] = useState(() => localStorage.getItem('archiActiveP') || 'p1');
            const [activeVersionId, setActiveVersionId] = useState(() => localStorage.getItem('archiActiveV') || 'v1');

            const [isDarkMode, setIsDarkMode] = useState(() => localStorage.getItem('archiDarkMode') === 'true');
            const [layoutView, setLayoutView] = useState(() => localStorage.getItem('archiLayout') || 'Gantt');
            const [showTimelineTasks, setShowTimelineTasks] = useState(() => localStorage.getItem('archiShowTasks') === 'true');
            const [alwaysShowTaskNames, setAlwaysShowTaskNames] = useState(() => localStorage.getItem('archiShowNames') === 'true');

            const [showExportModal, setShowExportModal] = useState(false);
            const [isExporting, setIsExporting] = useState(false);

            const [showViewModal, setShowViewModal] = useState(false);
            const [rowHeight, setRowHeight] = useState(() => parseInt(localStorage.getItem('archiRowHeight')) || 30);
            const [textSize, setTextSize] = useState(() => parseInt(localStorage.getItem('archiTextSize')) || 13);
            const [columnVisibility, setColumnVisibility] = useState(() => {
                try { const s = localStorage.getItem('archiColVis'); if (s) return JSON.parse(s); } catch (e) { }
                return { party: true, duration: true, start: true, end: true };
            });
            const [pdfPaperSize, setPdfPaperSize] = useState(() => localStorage.getItem('archiPdfSize') || 'letter');

            const [contextMenu, setContextMenu] = useState(null); // { x, y, taskId }
            const [renameModal, setRenameModal] = useState(null);
            const [showShiftModal, setShowShiftModal] = useState(false);
            const [shiftTarget, setShiftTarget] = useState('All');
            const [shiftMode, setShiftMode] = useState('days'); // 'days' or 'date'
            const [shiftDays, setShiftDays] = useState(0);
            const [shiftDate, setShiftDate] = useState('');

            const activeProject = projects.find(p => p.id === activeProjectId) || projects[0];
            const activeVersion = activeProject.versions.find(v => v.id === activeVersionId) || activeProject.versions[0];
            const tasks = activeVersion.tasks || [];
            const phases = activeVersion.phases || [];
            const phaseColors = activeVersion.phaseColors || {};
            const phaseParents = activeVersion.phaseParents || {};

            useEffect(() => { localStorage.setItem('archiScheduleData', JSON.stringify(projects)); }, [projects]);
            useEffect(() => { localStorage.setItem('archiActiveP', activeProjectId); }, [activeProjectId]);
            useEffect(() => { localStorage.setItem('archiActiveV', activeVersionId); }, [activeVersionId]);
            useEffect(() => { localStorage.setItem('archiDarkMode', isDarkMode); }, [isDarkMode]);
            useEffect(() => { localStorage.setItem('archiLayout', layoutView); }, [layoutView]);
            useEffect(() => { localStorage.setItem('archiViewMode', viewMode); }, [viewMode]);
            useEffect(() => { localStorage.setItem('archiShowTasks', showTimelineTasks); }, [showTimelineTasks]);
            useEffect(() => { localStorage.setItem('archiShowNames', alwaysShowTaskNames); }, [alwaysShowTaskNames]);
            useEffect(() => { localStorage.setItem('archiExpandedPhases', JSON.stringify(expandedPhases)); }, [expandedPhases]);
            useEffect(() => { localStorage.setItem('archiRowHeight', rowHeight); }, [rowHeight]);
            useEffect(() => { localStorage.setItem('archiTextSize', textSize); }, [textSize]);
            useEffect(() => { localStorage.setItem('archiColVis', JSON.stringify(columnVisibility)); }, [columnVisibility]);
            useEffect(() => { localStorage.setItem('archiPdfSize', pdfPaperSize); }, [pdfPaperSize]);

            const updateVersion = useCallback((taskUpdater, phaseUpdater, colorUpdater, typeOverride = null, parentUpdater = null) => {
                setProjects(prev => prev.map(p => {
                    if (p.id !== activeProjectId) return p;
                    return {
                        ...p,
                        versions: p.versions.map(v => {
                            if (v.id !== activeVersionId) return v;
                            const newTasks = taskUpdater ? taskUpdater(v.tasks) : v.tasks;
                            return {
                                ...v,
                                tasks: taskUpdater ? recalculateSchedule(newTasks, typeOverride || durationType) : v.tasks,
                                phases: phaseUpdater ? phaseUpdater(v.phases) : v.phases,
                                phaseColors: colorUpdater ? colorUpdater(v.phaseColors) : v.phaseColors,
                                phaseParents: parentUpdater ? parentUpdater(v.phaseParents || {}) : (v.phaseParents || {})
                            };
                        })
                    };
                }));
            }, [activeProjectId, activeVersionId, durationType]);

            const [dayWidth, setDayWidth] = useState(24);
            const [panelWidth, setPanelWidth] = useState(650);
            const [filterPhase, setFilterPhase] = useState('All');
            const [filterParty, setFilterParty] = useState('All');
            const [newPhaseName, setNewPhaseName] = useState('');
            const [editingPhase, setEditingPhase] = useState(null);

            const durationUnit = viewMode === 'Weeks' ? 'Weeks' : 'Days';
            const fileInputRef = useRef(null);

            const [expandedPhases, setExpandedPhases] = useState(() => {
                try {
                    const saved = localStorage.getItem('archiExpandedPhases');
                    if (saved) return JSON.parse(saved);
                } catch (e) { /* ignore */ }
                // Default: all phases expanded
                return {};
            });
            const [colWidths, setColWidths] = useState({ name: 220, party: 100, duration: 80, start: 120, end: 110 });

            // Drag & Drop / Resize States
            const [resizingCol, setResizingCol] = useState(null);
            const [resizingPanel, setResizingPanel] = useState(false);
            const [resizingTimeline, setResizingTimeline] = useState(null);
            const [dragTaskState, setDragTaskState] = useState(null);
            const [dragPhaseState, setDragPhaseState] = useState(null);
            const [linkingState, setLinkingState] = useState(null);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragOverTarget, setDragOverTarget] = useState(null);
            const [panelHoveredTask, setPanelHoveredTask] = useState(null);
            const [focusedTask, setFocusedTask] = useState(null);
            const [delayedActiveTask, setDelayedActiveTask] = useState(null);
            const hoverTimerRef = useRef(null);
            const rawActiveTaskId = panelHoveredTask || focusedTask;

            useEffect(() => {
                if (rawActiveTaskId) {
                    clearTimeout(hoverTimerRef.current);
                    setDelayedActiveTask(rawActiveTaskId);
                } else {
                    hoverTimerRef.current = setTimeout(() => setDelayedActiveTask(null), 300);
                }
                return () => clearTimeout(hoverTimerRef.current);
            }, [rawActiveTaskId]);

            const activeTaskId = delayedActiveTask;

            const timelineContainerRef = useRef(null);
            const exportTargetRef = useRef(null);
            const colorInputRef = useRef(null);
            const colorTargetRef = useRef(null);

            useEffect(() => {
                if (!resizingCol && !resizingTimeline && !resizingPanel && !dragTaskState && !dragPhaseState && !linkingState) return;

                const handleMouseMove = (e) => {
                    if (resizingCol) {
                        setColWidths(prev => ({ ...prev, [resizingCol.col]: Math.max(50, resizingCol.startWidth + (e.clientX - resizingCol.startX)) }));
                    } else if (resizingPanel) {
                        setPanelWidth(Math.max(300, e.clientX));
                    } else if (resizingTimeline) {
                        const newWeekWidth = Math.max(35, (resizingTimeline.startDayWidth * 7) + (e.clientX - resizingTimeline.startX));
                        setDayWidth(newWeekWidth / 7);
                    } else if (dragTaskState) {
                        const deltaCalendarDays = Math.round((e.clientX - dragTaskState.startX) / dayWidth);
                        if (dragTaskState.type === 'center') {
                            const newStartStr = addDays(dragTaskState.originalStartStr, deltaCalendarDays);
                            if (newStartStr !== dragTaskState.currentStartStr && isValidDateStr(newStartStr)) {
                                setDragTaskState(prev => ({ ...prev, currentStartStr: newStartStr }));
                                handleTaskChange(dragTaskState.taskId, 'start', newStartStr);
                            }
                        } else if (dragTaskState.type === 'right') {
                            const newVisualEndStr = addDays(dragTaskState.originalEndStr, deltaCalendarDays);
                            const newDur = getDurationBetweenDates(dragTaskState.originalStartStr, newVisualEndStr, durationType);
                            if (newDur !== dragTaskState.currentDuration) {
                                setDragTaskState(prev => ({ ...prev, currentDuration: newDur }));
                                handleTaskChange(dragTaskState.taskId, 'duration', newDur);
                            }
                        } else if (dragTaskState.type === 'left') {
                            const newStartStr = addDays(dragTaskState.originalStartStr, deltaCalendarDays);
                            if (isValidDateStr(newStartStr)) {
                                const newDur = getDurationBetweenDates(newStartStr, dragTaskState.originalEndStr, durationType);
                                if (newStartStr !== dragTaskState.currentStartStr || newDur !== dragTaskState.currentDuration) {
                                    setDragTaskState(prev => ({ ...prev, currentStartStr: newStartStr, currentDuration: newDur }));
                                    updateVersion(tList => tList.map(t => t.id === dragTaskState.taskId ? { ...t, start: newStartStr, duration: newDur, deps: [] } : t), null, null, durationType);
                                }
                            }
                        }
                    } else if (dragPhaseState) {
                        const deltaCalendarDays = Math.round((e.clientX - dragPhaseState.startX) / dayWidth);
                        if (deltaCalendarDays !== dragPhaseState.currentDelta) {
                            setDragPhaseState(prev => ({ ...prev, currentDelta: deltaCalendarDays }));
                        }
                    } else if (linkingState) {
                        const container = linkingState.panel === 'left' ? document.getElementById('pdf-left-panel').querySelector('.overflow-y-auto') : timelineContainerRef.current;
                        if (container) {
                            const rect = container.getBoundingClientRect();
                            setLinkingState(prev => ({ ...prev, currentX: e.clientX - rect.left + container.scrollLeft, currentY: (e.clientY - rect.top + container.scrollTop) - 64 }));
                        }
                    }
                };

                const handleMouseUp = (e) => {
                    if (linkingState) {
                        const targetTaskBar = document.elementFromPoint(e.clientX, e.clientY)?.closest('.task-bar-hitbox, .left-task-hitbox');
                        const targetId = targetTaskBar?.getAttribute('data-taskid');
                        if (targetId && targetId !== linkingState.sourceId) linkTasks(linkingState.sourceId, targetId);
                    } else if (dragPhaseState) {
                        const daysToShift = dragPhaseState.currentDelta;
                        if (daysToShift !== 0) {
                            const shiftTarget = dragPhaseState.phase;

                            // Check for links to earlier phases
                            let shouldBreakLinks = false;
                            const hasExternalLinks = tasks.some(t => {
                                if (t.phase === shiftTarget) {
                                    return t.deps.some(depId => {
                                        const depTask = tasks.find(dt => dt.id === depId);
                                        return depTask && depTask.phase !== shiftTarget;
                                    });
                                }
                                return false;
                            });

                            if (hasExternalLinks) {
                                shouldBreakLinks = window.confirm(`There are tasks in "${shiftTarget}" that are linked to tasks in other phases. Do you want to break these links before shifting?\n\nClick OK to break links and shift independently.\nClick Cancel to keep links (the shift may be overridden by existing dependencies).`);
                            }

                            updateVersion(prevTasks => {
                                let updated = JSON.parse(JSON.stringify(prevTasks));

                                if (shouldBreakLinks) {
                                    updated.forEach(t => {
                                        if (t.phase === shiftTarget) {
                                            t.deps = t.deps.filter(depId => {
                                                const depTask = updated.find(dt => dt.id === depId);
                                                return depTask && depTask.phase === shiftTarget;
                                            });
                                        }
                                    });
                                }

                                updated.forEach(t => {
                                    if (t.phase === shiftTarget) {
                                        t.start = addDays(t.start, daysToShift);
                                    }
                                });
                                return updated;
                            }, null, null, durationType);
                        }
                    }
                    setResizingCol(null); setResizingTimeline(null); setResizingPanel(false); setDragTaskState(null); setDragPhaseState(null); setLinkingState(null);
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); };
            }, [resizingCol, resizingTimeline, resizingPanel, dragTaskState, dragPhaseState, linkingState, dayWidth, durationType, updateVersion, tasks]);

            const handleContextMenu = useCallback((e, taskId) => {
                e.preventDefault();
                setContextMenu({ x: e.clientX, y: e.clientY, taskId });
            }, []);

            useEffect(() => {
                const closeContextMenu = () => setContextMenu(null);
                window.addEventListener('click', closeContextMenu);
                return () => window.removeEventListener('click', closeContextMenu);
            }, []);

            const handleItemDrop = (e, targetId, targetType, targetPhase) => {
                e.stopPropagation();
                if (!draggedItem) return;

                const dropPosition = dragOverTarget?.position || 'after'; // 'before' | 'inside' | 'after'

                if (draggedItem.type === 'task' && targetType === 'task') {
                    if (draggedItem.id === targetId) return;
                    updateVersion(prev => {
                        const result = [...prev];
                        const srcIdx = result.findIndex(t => t.id === draggedItem.id);
                        if (srcIdx < 0) return prev;
                        const [moved] = result.splice(srcIdx, 1);
                        moved.phase = targetPhase;
                        const tgtIdx = result.findIndex(t => t.id === targetId);
                        result.splice(tgtIdx >= 0 ? tgtIdx : result.length, 0, moved);
                        return result;
                    }, null, null, durationType);
                } else if (draggedItem.type === 'phase') {
                    if (draggedItem.id === targetId && targetType === 'phase') { setDraggedItem(null); setDragOverTarget(null); return; }

                    if (targetType === 'phase') {
                        // Phase dropped onto a Phase -> Use 3-zone logic
                        // Prevent circular dependency
                        if (dropPosition === 'inside') {
                            let curr = targetId;
                            let cycle = false;
                            while (curr) {
                                if (curr === draggedItem.id) { cycle = true; break; }
                                curr = phaseParents[curr];
                            }
                            if (cycle) { setDraggedItem(null); setDragOverTarget(null); return; }
                        }

                        updateVersion(
                            null,
                            prevPhases => {
                                const result = [...prevPhases];
                                const srcIdx = result.indexOf(draggedItem.id);
                                if (srcIdx < 0) return prevPhases;
                                result.splice(srcIdx, 1);

                                const tgtIdx = result.indexOf(targetId);
                                if (tgtIdx < 0) { result.push(draggedItem.id); return result; }

                                if (dropPosition === 'before') {
                                    result.splice(tgtIdx, 0, draggedItem.id);
                                } else {
                                    result.splice(tgtIdx + 1, 0, draggedItem.id);
                                }
                                return result;
                            },
                            null,
                            durationType,
                            prevParents => {
                                const next = { ...prevParents };
                                if (dropPosition === 'inside') {
                                    next[draggedItem.id] = targetId;
                                } else {
                                    const inheritParent = prevParents[targetId];
                                    if (inheritParent) {
                                        next[draggedItem.id] = inheritParent;
                                    } else {
                                        delete next[draggedItem.id];
                                    }
                                }
                                return next;
                            }
                        );
                    } else if (targetType === 'task') {
                        // Phase dropped onto a Task -> Append to the task's Phase
                        // Circular dependency guard
                        let curr = targetPhase;
                        let cycle = false;
                        while (curr) {
                            if (curr === draggedItem.id) { cycle = true; break; }
                            curr = phaseParents[curr];
                        }
                        if (cycle) { setDraggedItem(null); setDragOverTarget(null); return; }

                        updateVersion(
                            null,
                            prevPhases => {
                                const result = [...prevPhases];
                                const srcIdx = result.indexOf(draggedItem.id);
                                if (srcIdx < 0) return prevPhases;
                                result.splice(srcIdx, 1);

                                // Find the last phase that belongs to targetPhase
                                const lastChildIdx = result.findLastIndex(p => phaseParents[p] === targetPhase);
                                const insertIdx = lastChildIdx >= 0 ? lastChildIdx + 1 : (result.indexOf(targetPhase) + 1);
                                if (insertIdx > 0) {
                                    result.splice(insertIdx, 0, draggedItem.id);
                                } else {
                                    result.push(draggedItem.id);
                                }
                                return result;
                            },
                            null,
                            durationType,
                            prevParents => {
                                const next = { ...prevParents };
                                next[draggedItem.id] = targetPhase;
                                return next;
                            }
                        );
                    }
                } else if (draggedItem.type === 'task' && targetType === 'phase') {
                    updateVersion(prev => {
                        const result = [...prev];
                        const srcIdx = result.findIndex(t => t.id === draggedItem.id);
                        if (srcIdx < 0) return prev;
                        const [moved] = result.splice(srcIdx, 1);
                        moved.phase = targetPhase;
                        const lastIdx = result.findLastIndex(t => t.phase === targetPhase);
                        if (lastIdx >= 0) result.splice(lastIdx + 1, 0, moved);
                        else result.push(moved);
                        return result;
                    }, null, null, durationType);
                }
                setDraggedItem(null);
                setDragOverTarget(null);
            };

            const handleViewModeChange = (newMode) => {
                // Changing view mode is now purely visual and does not destructively recalculate internal task durations.
                setViewMode(newMode);
            };

            const handleTaskChange = useCallback((id, field, value) => {
                if (field === 'start' && (!value || !isValidDateStr(value))) return;
                updateVersion(prev => prev.map(t => {
                    if (t.id === id) {
                        let updated = { ...t, [field]: value };
                        if (field === 'duration' && value < 1) updated.duration = 1;
                        if (field === 'start') updated.deps = [];
                        return updated;
                    }
                    return t;
                }), null, null, durationType);
            }, [updateVersion, durationType]);

            const addTask = useCallback((phase) => {
                updateVersion(prev => [
                    ...prev,
                    { id: Math.random().toString(36).substr(2, 9), name: 'New Task', phase, party: 'Architect', start: prev.length > 0 ? addDays(calculateEndDate(prev[prev.length - 1].start, prev[prev.length - 1].duration, durationType), 1) : new Date().toISOString().split('T')[0], duration: durationUnit === 'Weeks' ? 5 : 5, milestone: 0, deps: prev.length > 0 ? [prev[prev.length - 1].id] : [] }
                ], null, null, durationType);
            }, [durationUnit, durationType, updateVersion]);

            const deleteTask = useCallback((id) => {
                updateVersion(prev => prev.filter(t => t.id !== id).map(t => ({ ...t, deps: t.deps.filter(depId => depId !== id) })), null, null, durationType);
            }, [updateVersion, durationType]);

            const handleDeletePhase = (phase) => {
                const phaseTasks = tasks.filter(t => t.phase === phase);
                if (phaseTasks.length > 0 && !window.confirm(`Delete "${phase}" and its ${phaseTasks.length} tasks?`)) return;
                const tasksToDelete = new Set(phaseTasks.map(t => t.id));
                updateVersion(
                    prev => prev.filter(t => !tasksToDelete.has(t.id)).map(t => ({ ...t, deps: t.deps.filter(d => !tasksToDelete.has(d)) })),
                    prev => prev.filter(p => p !== phase),
                    prev => { const c = { ...prev }; delete c[phase]; return c; },
                    durationType
                );
            };

            const handleRenamePhaseSubmit = () => {
                if (!editingPhase) return;
                const { oldName, tempName } = editingPhase;
                const trimmed = tempName.trim();
                if (trimmed && trimmed !== oldName && !phases.includes(trimmed)) {
                    updateVersion(
                        prevTasks => prevTasks.map(t => t.phase === oldName ? { ...t, phase: trimmed } : t),
                        prevPhases => prevPhases.map(p => p === oldName ? trimmed : p),
                        prevColors => { const c = { ...prevColors }; if (c[oldName]) { c[trimmed] = c[oldName]; delete c[oldName]; } return c; },
                        durationType,
                        prevParents => {
                            const next = { ...prevParents };
                            if (next[oldName]) { next[trimmed] = next[oldName]; delete next[oldName]; }
                            Object.keys(next).forEach(k => { if (next[k] === oldName) next[k] = trimmed; });
                            return next;
                        }
                    );
                    if (filterPhase === oldName) setFilterPhase(trimmed);
                    if (expandedPhases[oldName] !== undefined) {
                        setExpandedPhases(prev => {
                            const next = { ...prev };
                            next[trimmed] = next[oldName];
                            delete next[oldName];
                            return next;
                        });
                    }
                } else if (phases.includes(trimmed) && trimmed !== oldName) {
                    alert(`A phase with the name "${trimmed}" already exists.`);
                }
                setEditingPhase(null);
            };

            const cycleMilestone = useCallback((id) => {
                updateVersion(prev => prev.map(t => {
                    if (t.id === id) {
                        const nextType = ((t.milestone || 0) + 1) % 3;
                        return { ...t, milestone: nextType, duration: nextType > 0 ? 1 : Math.max(t.duration, 5) };
                    }
                    return t;
                }), null, null, durationType);
            }, [updateVersion, durationType]);

            const linkTasks = useCallback((sourceId, targetId) => {
                updateVersion(prev => {
                    let target = prev.find(t => t.id === targetId);
                    if (!target) return prev;
                    if (target.deps.includes(sourceId)) return prev.map(t => t.id === targetId ? { ...t, deps: t.deps.filter(id => id !== sourceId) } : t);
                    return prev.map(t => t.id === targetId ? { ...t, deps: [...new Set([...t.deps, sourceId])] } : t);
                }, null, null, durationType);
            }, [updateVersion, durationType]);

            const addProject = () => {
                const newId = Math.random().toString(36).substr(2, 9);
                setProjects(prev => [...prev, { id: newId, name: 'New Project', clientName: '', versions: [{ id: 'v1', name: 'Base Schedule', tasks: [], phases: INITIAL_PHASES, phaseColors: INITIAL_PHASE_COLORS }] }]);
                setActiveProjectId(newId);
                setActiveVersionId('v1');
                setRenameModal({ type: 'project', id: newId, name: 'New Project', clientName: '' });
            };

            const duplicateVersion = () => {
                const newId = Math.random().toString(36).substr(2, 9);
                setProjects(prev => prev.map(p => p.id === activeProjectId ? { ...p, versions: [...p.versions, { ...activeVersion, id: newId, name: `${activeVersion.name} (Copy)` }] } : p));
                setActiveVersionId(newId);
            };

            const addBlankVersion = () => {
                const newId = Math.random().toString(36).substr(2, 9);
                setProjects(prev => prev.map(p => p.id === activeProjectId ? { ...p, versions: [...p.versions, { id: newId, name: `New Schedule`, tasks: [], phases: INITIAL_PHASES, phaseColors: INITIAL_PHASE_COLORS }] } : p));
                setActiveVersionId(newId);
                setRenameModal({ type: 'version', id: newId, name: 'New Schedule' });
            };

            const handleRenameSubmit = (e) => {
                e.preventDefault();
                if (!renameModal) return;
                if (renameModal.type === 'project') setProjects(prev => prev.map(p => p.id === renameModal.id ? { ...p, name: renameModal.name, clientName: renameModal.clientName } : p));
                else setProjects(prev => prev.map(p => p.id === activeProjectId ? { ...p, versions: p.versions.map(v => v.id === renameModal.id ? { ...v, name: renameModal.name } : v) } : p));
                setRenameModal(null);
            };

            const handleShiftSubmit = (e) => {
                e.preventDefault();

                let daysToShift = 0;

                if (shiftMode === 'days') {
                    daysToShift = parseInt(shiftDays, 10);
                    if (isNaN(daysToShift) || daysToShift === 0) {
                        setShowShiftModal(false);
                        return;
                    }
                } else if (shiftMode === 'date') {
                    if (!isValidDateStr(shiftDate)) {
                        setShowShiftModal(false);
                        return;
                    }

                    // Find earliest date in target
                    let earliestStr = null;
                    tasks.forEach(t => {
                        if (shiftTarget === 'All' || t.phase === shiftTarget) {
                            if (!earliestStr || t.start < earliestStr) earliestStr = t.start;
                        }
                    });

                    if (!earliestStr) {
                        setShowShiftModal(false);
                        return;
                    }

                    daysToShift = diffDays(earliestStr, shiftDate);
                    if (daysToShift === 0) {
                        setShowShiftModal(false);
                        return;
                    }
                }

                // Check for links to earlier phases if shifting a specific phase
                let shouldBreakLinks = false;
                if (shiftTarget !== 'All') {
                    const hasExternalLinks = tasks.some(t => {
                        if (t.phase === shiftTarget) {
                            return t.deps.some(depId => {
                                const depTask = tasks.find(dt => dt.id === depId);
                                return depTask && depTask.phase !== shiftTarget;
                            });
                        }
                        return false;
                    });

                    if (hasExternalLinks) {
                        shouldBreakLinks = window.confirm(`There are tasks in "${shiftTarget}" that are linked to tasks in other phases. Do you want to break these links before shifting?\n\nClick OK to break links and shift independently.\nClick Cancel to keep links (the shift may be overridden by existing dependencies).`);
                    }
                }

                updateVersion(prevTasks => {
                    let updated = JSON.parse(JSON.stringify(prevTasks));

                    if (shouldBreakLinks && shiftTarget !== 'All') {
                        updated.forEach(t => {
                            if (t.phase === shiftTarget) {
                                t.deps = t.deps.filter(depId => {
                                    const depTask = updated.find(dt => dt.id === depId);
                                    return depTask && depTask.phase === shiftTarget;
                                });
                            }
                        });
                    }

                    updated.forEach(t => {
                        if (shiftTarget === 'All' || t.phase === shiftTarget) {
                            t.start = addDays(t.start, daysToShift);
                        }
                    });
                    return updated;
                }, null, null, durationType);

                setShowShiftModal(false);
                setShiftDays(0);
                setShiftDate('');
                setShiftTarget('All');
                setShiftMode('days');
            };

            const exportNative = () => {
                const blob = new Blob([JSON.stringify(projects, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ArchiSchedule_Export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleImportNative = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (imported && imported[0] && imported[0].versions) {
                            setProjects(imported);
                            setActiveProjectId(imported[0].id);
                            setActiveVersionId(imported[0].versions[0].id);
                        } else alert("Invalid file structure.");
                    } catch (err) { alert("Error reading JSON file."); }
                };
                reader.readAsText(file);
                e.target.value = null;
            };

            // --- Derived State for Rendering ---
            const phaseChildrenMap = useMemo(() => {
                const map = {};
                phases.forEach(p => map[p] = []);
                phases.forEach(child => {
                    const parent = phaseParents[child];
                    if (parent && phases.includes(parent) && parent !== child) {
                        map[parent].push(child);
                    }
                });
                return map;
            }, [phases, phaseParents]);

            const topLevelPhases = useMemo(() => {
                return phases.filter(p => !phaseParents[p] || !phases.includes(phaseParents[p]));
            }, [phases, phaseParents]);

            const flattenedPhases = useMemo(() => {
                const result = [];
                const traverse = (phaseList, level) => {
                    phaseList.forEach(phase => {
                        let include = true;
                        if (filterPhase !== 'All') {
                            let isDesc = false;
                            let curr = phase;
                            while (curr && phases.includes(curr)) {
                                if (curr === filterPhase) { isDesc = true; break; }
                                curr = phaseParents[curr];
                            }
                            if (!isDesc) include = false;
                        }

                        if (include) {
                            result.push({ phase, level, hasChildren: phaseChildrenMap[phase]?.length > 0 });
                            traverse(phaseChildrenMap[phase], level + 1);
                        }
                    });
                };
                traverse(topLevelPhases, 0);
                return result;
            }, [topLevelPhases, phaseChildrenMap, filterPhase, phaseParents, phases]);

            const visiblePhases = useMemo(() => {
                return flattenedPhases.map(fp => fp.phase);
            }, [flattenedPhases]);

            const renderPhases = useMemo(() => {
                const result = [];
                const traverse = (phaseList, level) => {
                    phaseList.forEach(phase => {
                        let include = true;
                        if (filterPhase !== 'All') {
                            let isDesc = false;
                            let curr = phase;
                            while (curr && phases.includes(curr)) {
                                if (curr === filterPhase) { isDesc = true; break; }
                                curr = phaseParents[curr];
                            }
                            if (!isDesc) include = false;
                        }

                        if (include) {
                            result.push({ phase, level, hasChildren: phaseChildrenMap[phase]?.length > 0 });
                            if (expandedPhases[phase] !== false) {
                                traverse(phaseChildrenMap[phase], level + 1);
                            }
                        }
                    });
                };
                traverse(topLevelPhases, 0);
                return result;
            }, [topLevelPhases, phaseChildrenMap, filterPhase, phaseParents, phases, expandedPhases]);

            const filteredTasks = useMemo(() => tasks.filter(t => (filterPhase === 'All' || visiblePhases.includes(t.phase)) && (filterParty === 'All' || t.party === filterParty)), [tasks, filterPhase, filterParty, visiblePhases]);

            const timelineBounds = useMemo(() => getEarliestAndLatestDates(filteredTasks, durationType), [filteredTasks, durationType]);
            const totalDays = diffDays(timelineBounds.start.toISOString().split('T')[0], timelineBounds.end.toISOString().split('T')[0]);

            const timelineHeaders = useMemo(() => {
                const headers = { months: [], weeks: [], days: [] };
                let current = parseDate(timelineBounds.start.toISOString().split('T')[0]);
                let currentMonth = current.getUTCMonth();
                let monthStartDay = 0;

                for (let i = 0; i <= totalDays; i++) {
                    const d = parseDate(timelineBounds.start.toISOString().split('T')[0]);
                    d.setUTCDate(d.getUTCDate() + i);
                    const dStr = d.toISOString().split('T')[0];
                    headers.days.push({ offset: i, date: d, str: dStr, isWeekend: isWeekend(d), isHoliday: isHoliday(dStr) });
                    if (d.getUTCDay() === 1 || i === 0) headers.weeks.push({ dayOffset: i, date: d });

                    if (d.getUTCMonth() !== currentMonth || i === totalDays) {
                        headers.months.push({ name: d.toLocaleString('default', { month: 'long', year: 'numeric', timeZone: 'UTC' }), start: monthStartDay, width: i - monthStartDay });
                        currentMonth = d.getUTCMonth();
                        monthStartDay = i;
                    }
                }
                return headers;
            }, [timelineBounds, totalDays]);

            const tasksByPhase = useMemo(() => {
                const grouped = {};
                phases.forEach(p => grouped[p] = []);
                filteredTasks.forEach(t => grouped[t.phase].push(t));
                return grouped;
            }, [filteredTasks, phases]);

            const phaseBounds = useMemo(() => {
                const bounds = {};
                const getNestedTasks = (phase) => {
                    let collectedTasks = [...(tasksByPhase[phase] || [])];
                    if (phaseChildrenMap[phase]) {
                        phaseChildrenMap[phase].forEach(c => {
                            collectedTasks.push(...getNestedTasks(c));
                        });
                    }
                    return collectedTasks;
                };

                flattenedPhases.forEach(fp => {
                    const phase = fp.phase;
                    const pTasks = getNestedTasks(phase);
                    if (!pTasks || pTasks.length === 0) return;
                    let minS = pTasks[0].start;
                    let maxE = calculateEndDate(pTasks[0].start, pTasks[0].duration, durationType);
                    pTasks.forEach(t => {
                        if (t.start < minS) minS = t.start;
                        const e = calculateEndDate(t.start, t.duration, durationType);
                        if (e > maxE) maxE = e;
                    });
                    const offStart = diffDays(timelineBounds.start.toISOString().split('T')[0], minS);
                    const offEnd = diffDays(timelineBounds.start.toISOString().split('T')[0], maxE);
                    bounds[phase] = { minS, maxE, offStart, width: (offEnd - offStart + 1) * dayWidth };
                });
                return bounds;
            }, [tasksByPhase, flattenedPhases, phaseChildrenMap, durationType, timelineBounds, dayWidth]);

            const taskCoordinates = useMemo(() => {
                const coords = {};
                let yCursor = 0;
                renderPhases.forEach(rp => {
                    const phase = rp.phase;
                    yCursor += rowHeight; // Phase header height
                    if (expandedPhases[phase] !== false && tasksByPhase[phase] && tasksByPhase[phase].length > 0) {
                        tasksByPhase[phase].forEach(task => {
                            const endDate = calculateEndDate(task.start, task.duration, durationType);
                            const startOffset = diffDays(timelineBounds.start.toISOString().split('T')[0], task.start);
                            const endOffset = diffDays(timelineBounds.start.toISOString().split('T')[0], endDate);
                            let rightX = (endOffset + 1) * dayWidth;
                            if (task.milestone > 0) rightX = (startOffset * dayWidth) + (dayWidth / 2) + 10;
                            coords[task.id] = { startX: startOffset * dayWidth, endX: rightX, y: yCursor + (rowHeight / 2) };
                            yCursor += rowHeight;
                        });
                    }
                });
                return coords;
            }, [tasksByPhase, renderPhases, expandedPhases, timelineBounds, dayWidth, durationType, rowHeight]);

            const timelineItems = useMemo(() => {
                let currentY = 0;
                const items = [];
                visiblePhases.forEach((phase) => {
                    const pBounds = phaseBounds[phase];
                    if (!pBounds) return;

                    const pStartPercent = (pBounds.offStart / totalDays) * 100;
                    const pWidthPercent = (pBounds.width / (totalDays * dayWidth)) * 100;

                    items.push({ type: 'phase', phase, bounds: pBounds, y: currentY, left: pStartPercent, width: pWidthPercent });
                    currentY += showTimelineTasks ? 32 : 40;

                    if (showTimelineTasks) {
                        const pTasks = tasksByPhase[phase] || [];
                        pTasks.forEach(task => {
                            if (task.milestone > 0) return;
                            const tEnd = calculateEndDate(task.start, task.duration, durationType);
                            const offStart = diffDays(timelineBounds.start.toISOString().split('T')[0], task.start);
                            const offEnd = diffDays(timelineBounds.start.toISOString().split('T')[0], tEnd);
                            const left = (offStart / totalDays) * 100;
                            const width = ((offEnd - offStart + 1) / totalDays) * 100;

                            items.push({ type: 'task', task, phase, left, width, y: currentY });
                            currentY += 24;
                        });
                        currentY += 16;
                    }
                });
                return { items, totalHeight: currentY };
            }, [visiblePhases, phaseBounds, tasksByPhase, showTimelineTasks, totalDays, timelineBounds, durationType]);

            const visibleCols = ['name', ...(columnVisibility.party ? ['party'] : []), ...(columnVisibility.duration ? ['duration'] : []), ...(columnVisibility.start ? ['start'] : []), ...(columnVisibility.end ? ['end'] : [])];
            const tableInnerWidth = 32 + visibleCols.reduce((sum, col) => sum + colWidths[col], 0) + 16;
            const todayOffsetDays = diffDays(timelineBounds.start.toISOString().split('T')[0], new Date().toISOString().split('T')[0]);
            const showTodayLine = todayOffsetDays >= 0 && todayOffsetDays <= totalDays;

            // --- Advanced Exports ---
            const exportExcelGantt = async () => {
                setIsExporting(true);
                try {
                    if (!window.ExcelJS) {
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js');
                    }
                    const workbook = new window.ExcelJS.Workbook();
                    const worksheet = workbook.addWorksheet('Gantt Schedule', {
                        views: [{ state: 'frozen', xSplit: 6, ySplit: 6 }]
                    });

                    const hexToArgb = (hex) => {
                        let h = hex.replace('#', '');
                        if (h.length === 3) h = h.split('').map(c => c + c).join('');
                        if (h.length === 6) return 'FF' + h.toUpperCase();
                        return h.toUpperCase();
                    };

                    const toExcelDate = (isoStr) => {
                        const [y, m, d] = isoStr.split('-');
                        return new Date(Date.UTC(parseInt(y), parseInt(m) - 1, parseInt(d)));
                    };

                    const columns = [
                        { key: 'phase', width: 25 },
                        { key: 'name', width: 35 },
                        { key: 'party', width: 15 },
                        { key: 'duration', width: 10 },
                        { key: 'start', width: 15 },
                        { key: 'end', width: 15 }
                    ];

                    timelineHeaders.days.forEach((d, i) => {
                        columns.push({ key: `day_${i}`, width: 3.5 });
                    });

                    worksheet.columns = columns;

                    // Write titles
                    worksheet.mergeCells('A1:F1');
                    const titleCell = worksheet.getCell('A1');
                    titleCell.value = `${activeVersion.name}`;
                    titleCell.font = { name: 'Arial', size: 16, bold: true, color: { argb: 'FF0F172A' } };

                    worksheet.mergeCells('A2:F2');
                    const subtitleCell = worksheet.getCell('A2');
                    subtitleCell.value = `Project: ${activeProject.name}   |   ${activeProject.clientName ? `Client: ${activeProject.clientName}   |   ` : ''}Date: ${new Date().toLocaleDateString()}`;
                    subtitleCell.font = { name: 'Arial', size: 10, color: { argb: 'FF64748B' } };

                    // Set Row 6 Headers explicitly
                    const headerRow = worksheet.getRow(6);
                    headerRow.height = 36;
                    headerRow.getCell(1).value = 'Phase';
                    headerRow.getCell(2).value = 'Task Name';
                    headerRow.getCell(3).value = 'Party';
                    headerRow.getCell(4).value = 'Duration';
                    headerRow.getCell(5).value = 'Start Date';
                    headerRow.getCell(6).value = 'End Date';

                    timelineHeaders.days.forEach((d, i) => {
                        const cell = headerRow.getCell(6 + i + 1);
                        cell.value = toExcelDate(d.str);
                        cell.numFmt = 'm/d';
                    });

                    for (let i = 1; i <= 6 + timelineHeaders.days.length; i++) {
                        const cell = headerRow.getCell(i);
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };
                        cell.font = { name: 'Arial', size: i > 6 ? 8 : 10, bold: true, color: { argb: 'FF334155' } };
                        cell.alignment = { vertical: 'middle', horizontal: i > 6 ? 'center' : 'left', textRotation: i > 6 ? 90 : 0 };
                        cell.border = {
                            top: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                            bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                            left: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                            right: { style: 'thin', color: { argb: 'FFCBD5E1' } }
                        };
                    }

                    // Timeline Months Header Row 5
                    let currentMonth = "";
                    let startMonthCol = 7;
                    timelineHeaders.days.forEach((d, i) => {
                        const mStr = d.date.toLocaleString('default', { month: 'short', timeZone: 'UTC' }) + " '" + d.date.getUTCFullYear().toString().slice(-2);
                        if (mStr !== currentMonth || i === timelineHeaders.days.length - 1) {
                            if (currentMonth !== "") {
                                const endCol = i === timelineHeaders.days.length - 1 ? 6 + i + 1 : 6 + i;
                                if (endCol > startMonthCol) {
                                    worksheet.mergeCells(5, startMonthCol, 5, endCol - 1);
                                    const mCell = worksheet.getCell(5, startMonthCol);
                                    mCell.value = currentMonth;
                                    mCell.font = { name: 'Arial', size: 9, bold: true, color: { argb: 'FF475569' } };
                                    mCell.alignment = { horizontal: 'center', vertical: 'middle' };
                                    mCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF1F5F9' } };
                                    mCell.border = {
                                        top: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                                        bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                                        left: { style: 'thin', color: { argb: 'FFCBD5E1' } },
                                        right: { style: 'thin', color: { argb: 'FFCBD5E1' } }
                                    };
                                }
                            }
                            currentMonth = mStr;
                            startMonthCol = 6 + i + 1;
                        }
                    });

                    const holidaySheet = workbook.addWorksheet('Holidays', { state: 'hidden' });
                    HOLIDAYS.forEach((h, idx) => {
                        holidaySheet.getCell(`A${idx + 1}`).value = toExcelDate(h);
                    });
                    const holidaysRange = `Holidays!$A$1:$A$${HOLIDAYS.length}`;

                    let currentRowNum = 7;

                    flattenedPhases.forEach(fp => {
                        const p = fp.phase;
                        const level = fp.level;
                        if (!tasksByPhase[p] || tasksByPhase[p].length === 0) return;

                        const phaseRow = worksheet.getRow(currentRowNum);
                        phaseRow.height = 20;
                        const indentStr = '  '.repeat(level);
                        phaseRow.getCell(1).value = indentStr + p;
                        phaseRow.getCell(1).font = { name: 'Arial', size: 10, bold: true, color: { argb: 'FF0F172A' } };
                        phaseRow.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF1F5F9' } };
                        worksheet.mergeCells(currentRowNum, 1, currentRowNum, 6);

                        for (let i = 1; i <= 6; i++) {
                            phaseRow.getCell(i).border = { bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } } };
                        }

                        // Apply weekend borders to phase row timeline
                        for (let col = 7; col <= 6 + timelineHeaders.days.length; col++) {
                            const isH = timelineHeaders.days[col - 7].isHoliday;
                            const isW = timelineHeaders.days[col - 7].isWeekend;
                            phaseRow.getCell(col).border = { bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } } };
                            if (isH || isW) phaseRow.getCell(col).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: isH ? 'FFFEE2E2' : 'FFF1F5F9' } };
                        }

                        currentRowNum++;

                        tasksByPhase[p].forEach(t => {
                            const row = worksheet.getRow(currentRowNum);
                            row.height = 18;

                            const isMS = t.milestone > 0;
                            row.getCell(1).value = p;
                            row.getCell(1).font = { color: { argb: 'FFFFFFFF' } }; // Invisible phase name for filtering

                            row.getCell(2).value = t.name;
                            row.getCell(2).font = { name: 'Arial', size: 9, bold: isMS, color: { argb: isMS ? (t.milestone === 2 ? 'FF059669' : 'FFD97706') : 'FF334155' } };
                            row.getCell(2).alignment = { indent: 1 };

                            row.getCell(3).value = t.party;
                            row.getCell(3).font = { name: 'Arial', size: 9 };

                            const durCell = row.getCell(4);
                            if (isMS) {
                                durCell.value = 'M';
                            } else {
                                let exportDur = t.duration;
                                if (viewMode === 'Weeks') exportDur = Math.ceil(t.duration / 5);
                                else if (viewMode === 'Days') exportDur = getDurationBetweenDates(t.start, calculateEndDate(t.start, t.duration, 'Business'), 'Calendar');
                                durCell.value = exportDur;
                                durCell.dataValidation = { type: 'whole', operator: 'greaterThan', formula1: 0, showErrorMessage: true, errorTitle: 'Invalid Duration', error: 'Duration must be > 0' };
                            }
                            durCell.alignment = { horizontal: 'center' };
                            durCell.font = { name: 'Arial', size: 9 };

                            const startCell = row.getCell(5);
                            startCell.value = toExcelDate(t.start);
                            startCell.numFmt = 'mm/dd/yyyy';
                            startCell.font = { name: 'Arial', size: 9 };

                            const endCell = row.getCell(6);
                            if (isMS) {
                                endCell.value = toExcelDate(t.start);
                            } else {
                                // Always use Business duration type calculation logic for internal consistency. Excel should mirror the schedule correctly using Business Days.
                                endCell.value = { formula: `WORKDAY(E${currentRowNum}-1, D${currentRowNum}, ${holidaysRange})` };
                            }
                            endCell.numFmt = 'mm/dd/yyyy';
                            endCell.font = { name: 'Arial', size: 9, color: { argb: 'FF64748B' } };
                            if (!isMS) endCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8FAFC' } };

                            for (let i = 1; i <= 6; i++) {
                                row.getCell(i).border = {
                                    bottom: { style: 'thin', color: { argb: 'FFF1F5F9' } },
                                    right: i === 6 ? { style: 'thin', color: { argb: 'FFCBD5E1' } } : undefined
                                };
                            }

                            // Weekend data rows
                            for (let col = 7; col <= 6 + timelineHeaders.days.length; col++) {
                                const isH = timelineHeaders.days[col - 7].isHoliday;
                                const isW = timelineHeaders.days[col - 7].isWeekend;
                                const cell = row.getCell(col);

                                cell.border = {
                                    bottom: { style: 'thin', color: { argb: 'FFF1F5F9' } },
                                    right: { style: 'thin', color: { argb: 'FFF8FAFC' } }
                                };

                                if (isH || isW) {
                                    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: isH ? 'FFFEE2E2' : 'FFF1F5F9' } };
                                    cell.border = {
                                        left: { style: 'thin', color: { argb: 'FFE2E8F0' } },
                                        right: { style: 'thin', color: { argb: 'FFE2E8F0' } },
                                        bottom: { style: 'thin', color: { argb: 'FFF1F5F9' } }
                                    };
                                }
                            }

                            row.outlineLevel = 1;
                            currentRowNum++;
                        });
                    });

                    const startDataRow = 7;
                    const endDataRow = currentRowNum - 1;
                    const getColLetter = (col) => {
                        let letter = '';
                        while (col > 0) {
                            let temp = (col - 1) % 26;
                            letter = String.fromCharCode(temp + 65) + letter;
                            col = (col - temp - 1) / 26;
                        }
                        return letter;
                    };
                    const cfcStartColLexer = getColLetter(7);
                    const cfcEndColLexer = getColLetter(6 + timelineHeaders.days.length);

                    if (endDataRow >= startDataRow && timelineHeaders.days.length > 0) {
                        const gridRange = `${cfcStartColLexer}${startDataRow}:${cfcEndColLexer}${endDataRow}`;

                        const rules = [];

                        // 1. Phases
                        visiblePhases.forEach(p => {
                            const phaseColorArgb = hexToArgb(phaseColors[p] || '#94a3b8');
                            rules.push({
                                priority: 5, // Lower priority than tasks/milestones
                                type: 'expression',
                                formulae: [`AND($A7="${p.replace(/"/g, '""')}", ${cfcStartColLexer}$6>=$E7, ${cfcStartColLexer}$6<=$F7)`],
                                style: {
                                    fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: phaseColorArgb } },
                                    border: {
                                        top: { style: 'thin', color: { argb: phaseColorArgb } },
                                        bottom: { style: 'thin', color: { argb: phaseColorArgb } }
                                    }
                                }
                            });
                        });

                        // 2. Milestones (General)
                        rules.push({
                            priority: 2,
                            type: 'expression',
                            formulae: [`AND(${cfcStartColLexer}$6>=$E7,${cfcStartColLexer}$6<=$F7,$D7="M")`],
                            style: {
                                fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FFD97706' } } // amber-600
                            }
                        });

                        // 3. Owner Milestones (Specific)
                        rules.push({
                            priority: 1,
                            type: 'expression',
                            formulae: [`AND(${cfcStartColLexer}$6>=$E7,${cfcStartColLexer}$6<=$F7,$D7="M", $C7="Owner")`],
                            style: {
                                fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FF059669' } } // emerald-600
                            }
                        });

                        // 4. Custom Colored Tasks and Milestones
                        let currentTaskRowIndex = startDataRow;
                        flattenedPhases.forEach(fp => {
                            const p = fp.phase;
                            if (!tasksByPhase[p] || tasksByPhase[p].length === 0) return;
                            // Skip phase header row
                            currentTaskRowIndex++;
                            const pTasks = tasksByPhase[p];
                            if (pTasks) {
                                pTasks.forEach(t => {
                                    if (t.color) {
                                        const argbColor = 'FF' + t.color.replace('#', '').toUpperCase();
                                        rules.push({
                                            priority: 0, // Highest priority
                                            type: 'expression',
                                            formulae: [`AND(ROW()=${currentTaskRowIndex}, ${cfcStartColLexer}$6>=$E${currentTaskRowIndex}, ${cfcStartColLexer}$6<=$F${currentTaskRowIndex})`],
                                            style: {
                                                fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: argbColor } }
                                            }
                                        });
                                    }
                                    currentTaskRowIndex++;
                                });
                            }
                        });

                        // 5. Default Task Bar
                        rules.push({
                            priority: 3,
                            type: 'expression',
                            formulae: [`AND(${cfcStartColLexer}$6>=$E7,${cfcStartColLexer}$6<=$F7,$D7<>"M")`],
                            style: {
                                fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FF94A3B8' } } // slate-400
                            }
                        });

                        worksheet.addConditionalFormatting({
                            ref: gridRange,
                            rules: rules
                        });
                    }

                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${activeProject.name}_${activeVersion.name}_Gantt.xlsx`.replace(/\s+/g, '_');
                    a.click();
                    URL.revokeObjectURL(url);
                } catch (err) {
                    console.error(err);
                    alert("Failed to export Excel! " + err.message);
                }
                setIsExporting(false);
                setShowExportModal(false);
            };

            const exportPDF = async () => {
                setIsExporting(true);
                try {
                    if (!window.jspdf) {
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
                    }
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF('landscape', 'pt', pdfPaperSize);
                    const hexToRgb = (hex) => {
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 100, g: 100, b: 100 };
                    };
                    const blendWhite = (rgb, a) => ({ r: Math.round(rgb.r * a + 255 * (1 - a)), g: Math.round(rgb.g * a + 255 * (1 - a)), b: Math.round(rgb.b * a + 255 * (1 - a)) });
                    const margin = 40;
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const drawHeader = (pageNum, totalPages, titlePostfix) => {
                        doc.setFont("helvetica", "bold"); doc.setFontSize(16); doc.setTextColor(15, 23, 42);
                        doc.text(`${activeVersion.name}${titlePostfix || ''}`, margin, margin);
                        doc.setFontSize(10); doc.setFont("helvetica", "normal"); doc.setTextColor(100, 116, 139);
                        doc.text(`Project: ${activeProject.name}   |   ${activeProject.clientName ? `Client: ${activeProject.clientName}   |   ` : ''}Date: ${new Date().toLocaleDateString()}`, margin, margin + 15);
                        doc.text(`Page ${pageNum} of ${totalPages || 1}`, pageWidth - margin - 60, margin + 15);
                        doc.setDrawColor(226, 232, 240); doc.setLineWidth(1);
                        doc.line(margin, margin + 25, pageWidth - margin, margin + 25);
                    };

                    if (layoutView === 'Timeline') {
                        drawHeader(1, 1);
                        const topOffset = margin + 60;
                        const timelineW = pageWidth - margin * 2;
                        const axisY = topOffset + ((pageHeight - topOffset - 60) / 2) - 20;
                        doc.setDrawColor(203, 213, 225); doc.setLineWidth(2);
                        doc.line(margin, axisY, margin + timelineW, axisY);
                        const milestones = filteredTasks.filter(t => t.milestone > 0);
                        milestones.forEach((m) => {
                            const offsetDays = diffDays(timelineBounds.start.toISOString().split('T')[0], m.start);
                            const percent = Math.max(0, Math.min(1, offsetDays / totalDays));
                            const x = margin + percent * timelineW;
                            const isOwner = m.milestone === 2;
                            const h = isOwner ? 70 : 40;
                            doc.setDrawColor(203, 213, 225); doc.setLineWidth(1);
                            doc.line(x, axisY, x, axisY - h);
                            if (m.color) { const mc = hexToRgb(m.color); doc.setFillColor(mc.r, mc.g, mc.b); }
                            else if (isOwner) doc.setFillColor(16, 185, 129);
                            else doc.setFillColor(251, 191, 36);
                            const size = 4;
                            doc.triangle(x, axisY - size, x + size, axisY, x, axisY + size, 'F');
                            doc.triangle(x, axisY - size, x - size, axisY, x, axisY + size, 'F');
                            doc.setFontSize(8); doc.setFont("helvetica", isOwner ? "bold" : "normal");
                            if (m.color) { const mc = hexToRgb(m.color); doc.setTextColor(mc.r, mc.g, mc.b); }
                            else doc.setTextColor(isOwner ? 4 : 51, isOwner ? 120 : 65, isOwner ? 87 : 85);
                            const textW = doc.getTextWidth(m.name) + 10;
                            const textX = Math.max(margin, Math.min(pageWidth - margin - textW, x - (textW / 2)));
                            const textY = axisY - h - 15;
                            doc.setDrawColor(226, 232, 240);
                            if (m.color) { const mc = hexToRgb(m.color); const bg = blendWhite(mc, 0.1); doc.setFillColor(bg.r, bg.g, bg.b); }
                            else doc.setFillColor(isOwner ? 209 : 248, isOwner ? 250 : 250, isOwner ? 229 : 252);
                            doc.roundedRect(textX, textY, textW, 14, 2, 2, 'FD');
                            doc.text(m.name, textX + 5, textY + 10);
                            doc.setFontSize(7); doc.setTextColor(148, 163, 184);
                            doc.text(formatShortDate(m.start), x, textY - 4, { align: 'center' });
                        });
                        let currentY = axisY + 20;
                        visiblePhases.forEach((phase) => {
                            const pBounds = phaseBounds[phase];
                            if (!pBounds) return;
                            const pStartPercent = pBounds.offStart / totalDays;
                            const pEndPercent = pBounds.offEnd / totalDays;
                            const pWidthPercent = pEndPercent - pStartPercent;
                            const x = margin + pStartPercent * timelineW;
                            const w = Math.max(pWidthPercent * timelineW, 2);
                            const colorStr = phaseColors[phase] || '#94a3b8';
                            const rgb = hexToRgb(colorStr);
                            doc.setFillColor(rgb.r, rgb.g, rgb.b);
                            doc.roundedRect(x, currentY, w, 14, 3, 3, 'F');
                            doc.setFontSize(8); doc.setFont("helvetica", "bold"); doc.setTextColor(255, 255, 255);
                            let text = phase;
                            if (doc.getTextWidth(text) > w - 10) { text = text.substring(0, Math.floor((w - 10) / 5)) + '...'; if (w < 20) text = ''; }
                            if (text) doc.text(text, x + 5, currentY + 10);
                            doc.setFontSize(7); doc.setTextColor(148, 163, 184);
                            doc.text(formatShortDate(pBounds.minS), x, currentY - 2);
                            doc.text(formatShortDate(pBounds.maxE), x + w, currentY - 2, { align: 'right' });
                            currentY += showTimelineTasks ? 20 : 25;
                            if (showTimelineTasks) {
                                const pTasks = tasksByPhase[phase] || [];
                                pTasks.forEach(task => {
                                    if (task.milestone > 0) return;
                                    const tEnd = calculateEndDate(task.start, task.duration, durationType);
                                    const offStart = diffDays(timelineBounds.start.toISOString().split('T')[0], task.start);
                                    const offEnd = diffDays(timelineBounds.start.toISOString().split('T')[0], tEnd);
                                    const left = offStart / totalDays; const width = (offEnd - offStart + 1) / totalDays;
                                    const tx = margin + left * timelineW; const tw = Math.max(width * timelineW, 2);
                                    const tColor = task.color || phaseColors[phase] || '#94a3b8';
                                    const tRgb = hexToRgb(tColor);
                                    doc.setFillColor(Math.min(255, tRgb.r + 30), Math.min(255, tRgb.g + 30), Math.min(255, tRgb.b + 30));
                                    doc.roundedRect(tx, currentY, tw, 10, 1, 1, 'F');
                                    doc.setFontSize(7); doc.setFont("helvetica", "bold"); doc.setTextColor(255, 255, 255);
                                    let tName = task.name;
                                    if (doc.getTextWidth(tName) > tw - 4) { tName = tName.substring(0, Math.floor((tw - 4) / 4)) + '...'; if (tw < 15) tName = ''; }
                                    if (tName) doc.text(tName, tx + 2, currentY + 8);
                                    currentY += 12;
                                });
                                currentY += 10;
                            }
                        });
                    } else {
                        // === GANTT VIEW PDF ===
                        const topOffset = margin + 40;
                        const pdfRowH = Math.max(14, Math.round(rowHeight * 0.6));
                        const maxRowsPerPage = Math.floor((pageHeight - topOffset - 40) / pdfRowH);
                        // Convert UI pixel widths directly to PDF points (1px = 0.75pt)
                        const pxToPt = 0.75;
                        const usableWidth = pageWidth - margin * 2;
                        const tableWidth = Math.min(panelWidth * pxToPt, usableWidth * 0.6);
                        const pdfVisibleCols = [{ key: 'name', label: 'Task Name' }];
                        if (columnVisibility.party) pdfVisibleCols.push({ key: 'party', label: 'Party' });
                        if (columnVisibility.duration) pdfVisibleCols.push({ key: 'duration', label: 'duration' });
                        if (columnVisibility.start) pdfVisibleCols.push({ key: 'start', label: 'Start' });
                        if (columnVisibility.end) pdfVisibleCols.push({ key: 'end', label: 'End' });
                        const totalColW = pdfVisibleCols.reduce((sum, c) => sum + colWidths[c.key], 0);
                        const scale = tableWidth / (totalColW * pxToPt);
                        const pdfCols = {};
                        let colX = margin;
                        pdfVisibleCols.forEach(c => {
                            const w = colWidths[c.key] * pxToPt * scale;
                            pdfCols[c.key] = { x: colX, w };
                            colX += w;
                        });
                        const cName = pdfCols.name;
                        const cParty = pdfCols.party || { x: 0, w: 0 };
                        const cDur = pdfCols.duration || { x: 0, w: 0 };
                        const cStart = pdfCols.start || { x: 0, w: 0 };
                        const cEnd = pdfCols.end || { x: 0, w: 0 };
                        const timelineX = margin + tableWidth;
                        const timelineMaxW = usableWidth - tableWidth;
                        // Build rows from renderPhases (respects expand/collapse)
                        const rows = [];
                        renderPhases.forEach(rp => {
                            const p = rp.phase; const level = rp.level;
                            const pTasks = tasksByPhase[p];
                            const isExpanded = expandedPhases[p] !== false;
                            rows.push({ type: 'phase', phase: p, level });
                            if (isExpanded && pTasks && pTasks.length > 0) {
                                pTasks.forEach(t => rows.push({ type: 'task', phase: p, task: t, level }));
                            }
                        });
                        if (rows.length === 0) {
                            rows.push({ type: 'task', phase: 'None', task: { name: 'No tasks', party: '', duration: 1, start: new Date().toISOString().split('T')[0], milestone: 0, deps: [] }, level: 0 });
                        }
                        let maxTaskEndIdx = 0;
                        rows.forEach(r => {
                            if (r.type === 'task') {
                                const endDateStr = calculateEndDate(r.task.start, r.task.duration, durationType);
                                const eIdx = diffDays(timelineBounds.start.toISOString().split('T')[0], endDateStr);
                                if (eIdx > maxTaskEndIdx) maxTaskEndIdx = eIdx;
                            }
                        });
                        const pdfTotalDays = Math.max(1, Math.min(totalDays, maxTaskEndIdx + 5));
                        // Always scale timeline to fit page width (no horizontal pagination)
                        const printDayWidth = timelineMaxW / Math.max(1, pdfTotalDays);
                        const startDayIdx = 0;
                        const endDayIdx = pdfTotalDays;
                        const vPages = Math.ceil(rows.length / maxRowsPerPage);
                        const totalPages = vPages;
                        let pageNum = 1;
                        for (let v = 0; v < vPages; v++) {
                            const startRowInfo = v * maxRowsPerPage;
                            if (startRowInfo >= rows.length) break;
                            if (pageNum > 1) doc.addPage();
                            drawHeader(pageNum, totalPages, '');
                            let startY = topOffset;
                            // Table Header
                            doc.setFillColor(248, 250, 252);
                            doc.rect(margin, startY, pageWidth - margin * 2, 30, 'F');
                            doc.setFont("helvetica", "bold"); doc.setFontSize(9); doc.setTextColor(51, 65, 85);
                            doc.text("Task Name", cName.x + 5, startY + 20);
                            if (columnVisibility.party) doc.text("Party", cParty.x + 3, startY + 20);
                            const durHeader = `Dur (${viewMode === 'Days' ? 'Cal' : viewMode === 'Weeks' ? 'Wks' : 'Bus'})`;
                            if (columnVisibility.duration) doc.text(durHeader, cDur.x + 3, startY + 20);
                            if (columnVisibility.start) doc.text("Start", cStart.x + 3, startY + 20);
                            if (columnVisibility.end) doc.text("End", cEnd.x + 3, startY + 20);
                            doc.setDrawColor(203, 213, 225);
                            doc.line(timelineX, startY, timelineX, startY + 30);
                            // Timeline Header (Months & Days)
                            let currentMonthStr = ""; let monthStartX = timelineX;
                            doc.setFontSize(8); doc.setFont("helvetica", "normal");
                            for (let i = startDayIdx; i <= endDayIdx; i++) {
                                if (i >= timelineHeaders.days.length) break;
                                const d = timelineHeaders.days[i];
                                const x = timelineX + (i - startDayIdx) * printDayWidth;
                                const yStr = d.date.getUTCFullYear().toString().slice(-2);
                                const mStr = d.date.toLocaleString('default', { month: 'short', timeZone: 'UTC' }) + ' \'' + yStr;
                                if (mStr !== currentMonthStr || i === endDayIdx) {
                                    if (currentMonthStr !== "") {
                                        doc.text(currentMonthStr, monthStartX + 2, startY + 12);
                                        doc.setDrawColor(203, 213, 225); doc.line(x, startY, x, startY + 15);
                                    }
                                    currentMonthStr = mStr; monthStartX = x;
                                }
                                if (printDayWidth > 15) {
                                    doc.setTextColor(100, 116, 139);
                                    doc.text(`${d.date.getUTCDate()}`, x + (printDayWidth / 2), startY + 25, { align: 'center' });
                                } else if (d.date.getUTCDay() === 1) {
                                    doc.setTextColor(148, 163, 184);
                                    doc.text(`${d.date.getUTCMonth() + 1}/${d.date.getUTCDate()}`, x + 2, startY + 25);
                                }
                            }
                            doc.setDrawColor(226, 232, 240);
                            doc.line(margin, startY + 30, pageWidth - margin, startY + 30);
                            const startRow = v * maxRowsPerPage;
                            let endRow = Math.min(rows.length, startRow + maxRowsPerPage);
                            // Weekend Shading and Vertical Lines
                            for (let i = startDayIdx; i <= endDayIdx; i++) {
                                if (i >= timelineHeaders.days.length) break;
                                const d = timelineHeaders.days[i];
                                const x = timelineX + (i - startDayIdx) * printDayWidth;
                                if (d.isWeekend || d.isHoliday) {
                                    doc.setFillColor(d.isHoliday ? 254 : 248, d.isHoliday ? 242 : 250, d.isHoliday ? 242 : 252);
                                    doc.rect(x, startY + 30, printDayWidth, (endRow - startRow) * pdfRowH, 'F');
                                    doc.setDrawColor(241, 245, 249);
                                    doc.line(x, startY + 30, x, startY + 30 + (endRow - startRow) * pdfRowH);
                                }
                                if (d.date.getUTCDay() === 1) {
                                    doc.setDrawColor(226, 232, 240);
                                    doc.line(x, startY + 20, x, startY + 30 + (endRow - startRow) * pdfRowH);
                                } else if (printDayWidth > 10 && !d.isWeekend && !d.isHoliday) {
                                    doc.setDrawColor(245, 248, 250);
                                    doc.line(x, startY + 30, x, startY + 30 + (endRow - startRow) * pdfRowH);
                                }
                            }
                            // Today line
                            if (showTodayLine && todayOffsetDays >= startDayIdx && todayOffsetDays <= endDayIdx) {
                                const todayX = timelineX + (todayOffsetDays - startDayIdx) * printDayWidth;
                                doc.setDrawColor(239, 68, 68); doc.setLineWidth(1.5);
                                doc.line(todayX, startY + 30, todayX, startY + 30 + (endRow - startRow) * pdfRowH);
                                doc.setLineWidth(1);
                            }
                            // Draw Rows
                            startY += 30;
                            for (let r = startRow; r < endRow; r++) {
                                const row = rows[r];
                                const isPhase = row.type === 'phase';
                                const y = startY + (r - startRow) * pdfRowH;
                                const indent = (row.level || 0) * 14;
                                if (isPhase) {
                                    // Phase row with colored background
                                    const pColorStr = phaseColors[row.phase] || '#94a3b8';
                                    const pRgb = hexToRgb(pColorStr);
                                    const bgRgb = blendWhite(pRgb, 0.18);
                                    doc.setFillColor(bgRgb.r, bgRgb.g, bgRgb.b);
                                    doc.rect(margin, y, pageWidth - margin * 2, pdfRowH, 'F');
                                    // Phase color swatch
                                    doc.setFillColor(pRgb.r, pRgb.g, pRgb.b);
                                    doc.roundedRect(cName.x + 5 + indent, y + (pdfRowH / 2) - 5, 8, 10, 1, 1, 'F');
                                    // Phase name
                                    doc.setFont("helvetica", "bold"); doc.setTextColor(15, 23, 42); doc.setFontSize(10);
                                    let pName = row.phase;
                                    const maxNameW = cName.w - indent - 20;
                                    if (doc.getTextWidth(pName) > maxNameW) pName = pName.substring(0, Math.floor(maxNameW / 6)) + '...';
                                    doc.text(pName, cName.x + 17 + indent, y + (pdfRowH / 2) + 4);
                                    // Phase duration
                                    const phBounds = phaseBounds[row.phase];
                                    if (phBounds) {
                                        let pDur = 0;
                                        if (viewMode === 'Weeks') pDur = Math.ceil(getDurationBetweenDates(phBounds.minS, phBounds.maxE, 'Business') / 5);
                                        else if (viewMode === 'Days') pDur = getDurationBetweenDates(phBounds.minS, phBounds.maxE, 'Calendar');
                                        else pDur = getDurationBetweenDates(phBounds.minS, phBounds.maxE, 'Business');
                                        doc.setFont("helvetica", "normal"); doc.setFontSize(8); doc.setTextColor(100, 116, 139);
                                        if (columnVisibility.duration) doc.text(`${pDur}${viewMode === 'Weeks' ? 'w' : 'd'}`, cDur.x + 3, y + (pdfRowH / 2) + 3);
                                        if (columnVisibility.start) doc.text(formatShortDate(phBounds.minS), cStart.x + 3, y + (pdfRowH / 2) + 3);
                                        if (columnVisibility.end) doc.text(formatShortDate(phBounds.maxE), cEnd.x + 3, y + (pdfRowH / 2) + 3);
                                    }
                                    // Phase bar in timeline
                                    const pb = phaseBounds[row.phase];
                                    if (pb) {
                                        const pStartIdx = Math.max(0, pb.offStart);
                                        const pEndIdx = pb.offEnd;
                                        if (pEndIdx >= startDayIdx && pStartIdx <= endDayIdx) {
                                            const drawStart = Math.max(startDayIdx, pStartIdx);
                                            const drawEnd = Math.min(endDayIdx, pEndIdx);
                                            const barX = timelineX + (drawStart - startDayIdx) * printDayWidth;
                                            const barW = Math.max((drawEnd - drawStart) * printDayWidth, 2);
                                            doc.setFillColor(pRgb.r, pRgb.g, pRgb.b);
                                            doc.roundedRect(barX, y + (pdfRowH / 2) - 2, barW, 4, 1, 1, 'F');
                                        }
                                    }
                                } else {
                                    // Task row
                                    if ((r - startRow) % 2 === 1) {
                                        doc.setFillColor(248, 250, 252);
                                        doc.rect(margin, y, tableWidth, pdfRowH, 'F');
                                    }
                                    const t = row.task;
                                    const isMS = t.milestone > 0;
                                    const endDateStr = calculateEndDate(t.start, t.duration, durationType);
                                    // Task Name
                                    doc.setFont("helvetica", isMS ? "bold" : "normal");
                                    if (t.milestone === 2) doc.setTextColor(5, 150, 105);
                                    else if (t.milestone === 1) doc.setTextColor(217, 119, 6);
                                    else doc.setTextColor(51, 65, 85);
                                    doc.setFontSize(9);
                                    let nameDisp = t.name;
                                    const maxTNameW = cName.w - indent - 18;
                                    if (doc.getTextWidth(nameDisp) > maxTNameW) {
                                        while (doc.getTextWidth(nameDisp + '...') > maxTNameW && nameDisp.length > 0) nameDisp = nameDisp.slice(0, -1);
                                        nameDisp += '...';
                                    }
                                    doc.text(nameDisp, cName.x + 15 + indent, y + (pdfRowH / 2) + 3);
                                    // Party
                                    if (columnVisibility.party) {
                                        doc.setFont("helvetica", isMS ? "bold" : "normal");
                                        if (t.milestone === 2) doc.setTextColor(5, 150, 105);
                                        else if (t.milestone === 1) doc.setTextColor(217, 119, 6);
                                        else doc.setTextColor(100, 116, 139);
                                        doc.setFontSize(8);
                                        let partyDisp = t.party || '';
                                        const maxPartyW = cParty.w - 6;
                                        if (doc.getTextWidth(partyDisp) > maxPartyW) partyDisp = partyDisp.substring(0, Math.floor(maxPartyW / 4.5)) + '..';
                                        doc.text(partyDisp, cParty.x + 3, y + (pdfRowH / 2) + 3);
                                    }
                                    // Duration
                                    if (columnVisibility.duration) {
                                        let pdfDisplayDur = t.duration;
                                        if (viewMode === 'Weeks') pdfDisplayDur = Math.ceil(t.duration / 5);
                                        else if (viewMode === 'Days') pdfDisplayDur = getDurationBetweenDates(t.start, endDateStr, 'Calendar');
                                        const durLabel = isMS ? 'M' : `${pdfDisplayDur}${viewMode === 'Weeks' ? 'w' : 'd'}`;
                                        doc.text(durLabel, cDur.x + 3, y + (pdfRowH / 2) + 3);
                                    }
                                    // Start Date
                                    if (columnVisibility.start) {
                                        doc.setFont("helvetica", isMS ? "bold" : "normal");
                                        if (t.milestone === 2) doc.setTextColor(5, 150, 105);
                                        else if (t.milestone === 1) doc.setTextColor(217, 119, 6);
                                        else doc.setTextColor(51, 65, 85);
                                        doc.text(formatShortDate(t.start), cStart.x + 3, y + (pdfRowH / 2) + 3);
                                    }
                                    // End Date
                                    if (columnVisibility.end) {
                                        doc.setTextColor(100, 116, 139);
                                        doc.setFont("helvetica", "normal"); doc.setFontSize(8);
                                        doc.text(formatShortDate(endDateStr), cEnd.x + 3, y + (pdfRowH / 2) + 3);
                                    }
                                    // Gantt bars
                                    const tStartIdx = Math.max(0, diffDays(timelineBounds.start.toISOString().split('T')[0], t.start));
                                    const tEndIdx = diffDays(timelineBounds.start.toISOString().split('T')[0], endDateStr);
                                    if (tEndIdx >= 0 && tStartIdx < pdfTotalDays) {
                                        const colorStr = t.color || phaseColors[row.phase] || '#94a3b8';
                                        const rgb = hexToRgb(colorStr);
                                        let segments = [];
                                        if (viewMode === 'Business' && t.milestone === 0) {
                                            let currentSegStart = null;
                                            let current = parseDate(t.start); const endD = parseDate(endDateStr);
                                            while (current <= endD) {
                                                const dStr = current.toISOString().split('T')[0];
                                                if (!isNonWorkingDay(dStr, 'Business')) { if (!currentSegStart) currentSegStart = dStr; }
                                                else { if (currentSegStart) { segments.push({ start: currentSegStart, end: addDays(dStr, -1) }); currentSegStart = null; } }
                                                current.setUTCDate(current.getUTCDate() + 1);
                                            }
                                            if (currentSegStart) segments.push({ start: currentSegStart, end: endDateStr });
                                        } else { segments.push({ start: t.start, end: endDateStr }); }
                                        if (t.milestone > 0) {
                                            if (t.color) { const rgbMs = hexToRgb(t.color); doc.setFillColor(rgbMs.r, rgbMs.g, rgbMs.b); }
                                            else if (t.milestone === 2) doc.setFillColor(16, 185, 129);
                                            else doc.setFillColor(251, 191, 36);
                                            const cx = timelineX + (tStartIdx - startDayIdx) * printDayWidth + (printDayWidth / 2);
                                            const cy = y + (pdfRowH / 2); const sz = 5;
                                            doc.triangle(cx, cy - sz, cx + sz, cy, cx, cy + sz, 'F');
                                            doc.triangle(cx, cy - sz, cx - sz, cy, cx, cy + sz, 'F');
                                        } else {
                                            if (segments.length > 1) {
                                                const oDrawS = Math.max(startDayIdx, tStartIdx);
                                                const oDrawE = Math.min(endDayIdx, tEndIdx);
                                                if (oDrawE >= oDrawS) {
                                                    doc.setFillColor(Math.floor(rgb.r + (255 - rgb.r) * 0.8), Math.floor(rgb.g + (255 - rgb.g) * 0.8), Math.floor(rgb.b + (255 - rgb.b) * 0.8));
                                                    const oXS = timelineX + (oDrawS - startDayIdx) * printDayWidth;
                                                    const oXE = timelineX + ((oDrawE + 1) - startDayIdx) * printDayWidth;
                                                    doc.roundedRect(oXS, y + 4, Math.max(oXE - oXS, 2), pdfRowH - 8, 2, 2, 'F');
                                                }
                                            }
                                            segments.forEach(seg => {
                                                const segSI = diffDays(timelineBounds.start.toISOString().split('T')[0], seg.start);
                                                const segEI = diffDays(timelineBounds.start.toISOString().split('T')[0], seg.end);
                                                if (segEI >= startDayIdx && segSI <= endDayIdx) {
                                                    const dSI = Math.max(startDayIdx, segSI); const dEI = Math.min(endDayIdx, segEI);
                                                    const xS = timelineX + (dSI - startDayIdx) * printDayWidth;
                                                    const xE = timelineX + ((dEI + 1) - startDayIdx) * printDayWidth;
                                                    let w = xE - xS; if (w < 2) w = 2;
                                                    doc.setFillColor(rgb.r, rgb.g, rgb.b);
                                                    doc.roundedRect(xS, y + 4, w, pdfRowH - 8, 2, 2, 'F');
                                                }
                                            });
                                        }
                                    }
                                }
                                // Column dividers
                                doc.setDrawColor(226, 232, 240);
                                pdfVisibleCols.forEach((c, ci) => {
                                    if (ci > 0) doc.line(pdfCols[c.key].x, y, pdfCols[c.key].x, y + pdfRowH);
                                });
                                doc.line(timelineX, y, timelineX, y + pdfRowH);
                            }

                            // Bottom bounding line
                            doc.setDrawColor(203, 213, 225);
                            doc.line(margin, startY + (endRow - startRow) * pdfRowH, pageWidth - margin, startY + (endRow - startRow) * pdfRowH);
                            pageNum++;
                        }
                    }

                    const pdfBlob = doc.output('blob');
                    const url = URL.createObjectURL(pdfBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${activeProject.name.replace(/\s+/g, '_')}_Schedule.pdf`;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                } catch (err) {
                    console.error(err);
                    alert("Failed to export PDF! " + err.message);
                }
                setIsExporting(false);
                setShowExportModal(false);
            };


            const exportCSV = () => {
                let csv = 'Phase,Task Name,Party,Duration,Start Date,End Date\n';
                flattenedPhases.forEach(fp => {
                    const p = fp.phase;
                    if (tasksByPhase[p]) {
                        tasksByPhase[p].forEach(t => {
                            const endStr = calculateEndDate(t.start, t.duration, durationType);
                            let exportDur = t.duration;
                            if (viewMode === 'Weeks') exportDur = Math.ceil(t.duration / 5);
                            else if (viewMode === 'Days') exportDur = getDurationBetweenDates(t.start, endStr, 'Calendar');
                            csv += `"${p}","${t.name}","${t.party}","${exportDur}","${t.start}","${endStr}"\n`;
                        });
                    }
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${activeProject.name}_${activeVersion.name}.csv`.replace(/\s+/g, '_');
                a.click();
                URL.revokeObjectURL(url);
                setShowExportModal(false);
            };

            const exportMilestoneICS = () => {
                const icsContent = generateICS(filteredTasks);
                const blob = new Blob([icsContent], { type: 'text/calendar' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${activeProject.name}_Milestones.ics`.replace(/\s+/g, '_');
                a.click();
                URL.revokeObjectURL(url);
                setShowExportModal(false);
            };



            return (
                <div className={`flex flex-col h-screen font-sans transition-colors ${isDarkMode ? 'dark bg-slate-900 text-slate-100' : 'bg-slate-50 text-slate-800'} ${(resizingCol || resizingTimeline || resizingPanel) ? 'select-none' : ''} ${dragTaskState ? 'select-none' : ''}`}>
                    <input type="file" ref={fileInputRef} accept=".json" style={{ display: 'none' }} onChange={handleImportNative} />
                    <input type="color" ref={colorInputRef} style={{ position: 'fixed', visibility: 'hidden', width: 0, height: 0, left: contextMenu?.x || 0, top: contextMenu?.y || 0 }} onChange={(e) => { if (colorTargetRef.current) handleTaskChange(colorTargetRef.current, 'color', e.target.value); }} />

                    {/* --- TOP HEADER --- */}
                    <header className="bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700 px-6 py-3 flex items-center justify-between shadow-sm z-30 relative transition-colors">
                        <div className="flex items-center space-x-4">
                            <div className="bg-gradient-to-br from-indigo-500 to-indigo-700 p-2 rounded-xl shadow-inner text-white">
                                <Briefcase className="w-5 h-5" />
                            </div>
                            <div className="flex flex-col">
                                <h1 className="text-xl font-bold tracking-tight leading-tight text-slate-900 dark:text-white">ArchiSchedule</h1>

                                <div className="group relative flex items-center text-xs font-semibold text-slate-500 dark:text-slate-400 cursor-pointer hover:text-indigo-600 dark:hover:text-indigo-400 mt-0.5 pb-1">
                                    <Folder className="w-3 h-3 mr-1" /> {activeProject.name} <span className="mx-1">/</span> <FileIcon className="w-3 h-3 mr-1" /> {activeVersion.name}
                                    {activeProject.clientName && <><span className="mx-1">/</span> <Briefcase className="w-3 h-3 mr-1" /> {activeProject.clientName}</>}
                                    <ChevronDown className="w-3 h-3 ml-1" />

                                    <div className="absolute top-full left-0 w-72 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 py-2">
                                        <div className="text-[10px] font-bold uppercase tracking-wider text-slate-400 mb-1 px-4">Projects</div>
                                        <div className="px-2 mb-2">
                                            {projects.map(p => (
                                                <div key={p.id} className="flex items-center justify-between px-2 py-1.5 hover:bg-slate-50 dark:hover:bg-slate-700 rounded-md group/proj">
                                                    <button onClick={() => { setActiveProjectId(p.id); setActiveVersionId(p.versions[0].id); }} className={`flex-1 text-left text-sm font-medium truncate ${activeProjectId === p.id ? 'text-indigo-600 dark:text-indigo-400' : 'text-slate-700 dark:text-slate-200'}`}>
                                                        {p.name}
                                                    </button>
                                                    <button onClick={(e) => { e.stopPropagation(); setRenameModal({ type: 'project', id: p.id, name: p.name, clientName: p.clientName || '' }); }} className="opacity-0 group-hover/proj:opacity-100 text-slate-400 hover:text-indigo-600 p-1"><Edit2 className="w-3 h-3" /></button>
                                                </div>
                                            ))}
                                            <button onClick={addProject} className="w-full text-left px-2 py-1.5 text-xs font-bold text-indigo-600 dark:text-indigo-400 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 rounded-md mt-1 flex items-center"><Folder className="w-3.5 h-3.5 mr-1.5" /> New Project</button>
                                        </div>
                                        <div className="h-px bg-slate-100 dark:bg-slate-700 my-2"></div>
                                        <div className="text-[10px] font-bold uppercase tracking-wider text-slate-400 mb-1 px-4">Versions</div>
                                        <div className="px-2 mb-2">
                                            {activeProject.versions.map(v => (
                                                <div key={v.id} className="flex items-center justify-between px-2 py-1.5 hover:bg-slate-50 dark:hover:bg-slate-700 rounded-md group/ver">
                                                    <button onClick={() => setActiveVersionId(v.id)} className={`flex-1 text-left text-sm font-medium truncate flex items-center ${activeVersionId === v.id ? 'text-indigo-600 dark:text-indigo-400' : 'text-slate-700 dark:text-slate-200'}`}>
                                                        <FileIcon className="w-3.5 h-3.5 mr-2 opacity-50" /> {v.name}
                                                    </button>
                                                    <button onClick={(e) => { e.stopPropagation(); setRenameModal({ type: 'version', id: v.id, name: v.name }); }} className="opacity-0 group-hover/ver:opacity-100 text-slate-400 hover:text-indigo-600 p-1"><Edit2 className="w-3 h-3" /></button>
                                                </div>
                                            ))}
                                            <div className="flex space-x-1 mt-1">
                                                <button onClick={duplicateVersion} className="flex-1 text-left px-2 py-1.5 rounded-md text-xs font-bold text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-700 flex items-center justify-center">
                                                    <Copy className="w-3.5 h-3.5 mr-1" /> Duplicate
                                                </button>
                                                <button onClick={addBlankVersion} className="flex-1 text-left px-2 py-1.5 rounded-md text-xs font-bold text-indigo-600 dark:text-indigo-400 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 flex items-center justify-center">
                                                    <FilePlus className="w-3.5 h-3.5 mr-1" /> Blank
                                                </button>
                                            </div>
                                        </div>
                                        <div className="h-px bg-slate-100 dark:bg-slate-700 my-2"></div>
                                        <div className="px-2 flex flex-col space-y-1">
                                            <button onClick={() => fileInputRef.current.click()} className="w-full text-left px-2 py-1.5 rounded-md text-xs font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-700 flex items-center"><Upload className="w-3.5 h-3.5 mr-2" /> Import App File (.json)</button>
                                            <button onClick={exportNative} className="w-full text-left px-2 py-1.5 rounded-md text-xs font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-700 flex items-center"><Download className="w-3.5 h-3.5 mr-2" /> Export App File (.json)</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="flex items-center space-x-4">

                            {layoutView === 'Timeline' && (
                                <button onClick={() => setShowTimelineTasks(!showTimelineTasks)} className={`flex items-center px-3 py-1.5 rounded-md text-xs font-bold transition-all border shadow-sm ${showTimelineTasks ? 'bg-indigo-50 dark:bg-indigo-900/30 border-indigo-200 dark:border-indigo-800 text-indigo-700 dark:text-indigo-300' : 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-300'}`} title="Show individual events">
                                    <ListTree className="w-3.5 h-3.5 mr-1.5" /> Show Tasks
                                </button>
                            )}

                            <div className="flex items-center bg-slate-100 dark:bg-slate-900 p-1 rounded-lg border border-slate-200 dark:border-slate-700 shadow-inner">
                                <button onClick={() => setLayoutView('Gantt')} className={`flex items-center px-3 py-1.5 rounded-md text-xs font-bold transition-all ${layoutView === 'Gantt' ? 'bg-white dark:bg-slate-700 text-indigo-700 dark:text-indigo-300 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700'}`} title="Gantt View">
                                    <LayoutDashboard className="w-3.5 h-3.5 mr-1.5" /> Gantt
                                </button>
                                <button onClick={() => setLayoutView('Timeline')} className={`flex items-center px-3 py-1.5 rounded-md text-xs font-bold transition-all ${layoutView === 'Timeline' ? 'bg-white dark:bg-slate-700 text-indigo-700 dark:text-indigo-300 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700'}`} title="Timeline View">
                                    <Presentation className="w-3.5 h-3.5 mr-1.5" /> Timeline
                                </button>
                            </div>

                            <div className="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>

                            <div className="flex items-center space-x-2">
                                <button onClick={() => setShowViewModal(true)} className="flex items-center space-x-2 text-sm font-semibold text-slate-600 dark:text-slate-300 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded-lg border border-slate-200 dark:border-slate-600 shadow-sm" title="View Settings">
                                    <Eye className="w-4 h-4" /> <span>View</span>
                                </button>
                                <button onClick={() => setShowShiftModal(true)} className="flex items-center space-x-2 text-sm font-semibold text-slate-600 dark:text-slate-300 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded-lg border border-slate-200 dark:border-slate-600 shadow-sm" title="Shift Schedule">
                                    <CalendarDays className="w-4 h-4" /> <span>Shift</span>
                                </button>
                                <button onClick={() => setShowExportModal(true)} className="flex items-center space-x-2 text-sm font-semibold text-slate-600 dark:text-slate-300 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded-lg border border-slate-200 dark:border-slate-600 shadow-sm" title="Export">
                                    <Download className="w-4 h-4" /> <span>Export</span>
                                </button>
                            </div>

                            <div className="flex items-center bg-slate-100 dark:bg-slate-900 p-1 rounded-lg border border-slate-200 dark:border-slate-700 shadow-inner">
                                {[{ id: 'Weeks', label: 'Wks' }, { id: 'Business', label: 'Bus' }, { id: 'Days', label: 'Cal' }].map(mode => (
                                    <button key={mode.id} onClick={() => handleViewModeChange(mode.id)} className={`flex items-center px-3 py-1.5 rounded-md text-xs font-bold transition-all ${viewMode === mode.id ? 'bg-white dark:bg-slate-700 text-indigo-700 dark:text-indigo-300 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200'}`}>
                                        {mode.label}
                                    </button>
                                ))}
                            </div>

                            <div className="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>

                            <div className="flex items-center space-x-2">
                                <div className="relative flex items-center justify-center w-[30px] h-[30px] rounded-md bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors cursor-pointer group shadow-sm" title={filterPhase === 'All' ? 'Filter Phase (All)' : `Filter Phase (${filterPhase})`}>
                                    <Filter className="w-4 h-4 text-slate-500 dark:text-slate-400 group-hover:text-indigo-500 transition-colors" />
                                    <select className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value={filterPhase} onChange={(e) => setFilterPhase(e.target.value)}>
                                        <option value="All">All Phases</option>
                                        {phases.map(p => <option key={p} value={p}>{p}</option>)}
                                    </select>
                                    {filterPhase !== 'All' && <div className="absolute -top-1 -right-1 w-2.5 h-2.5 bg-indigo-500 rounded-full border border-white dark:border-slate-800"></div>}
                                </div>

                                <button onClick={() => setAlwaysShowTaskNames(!alwaysShowTaskNames)} className={`flex items-center px-3 py-1.5 rounded-md text-xs font-bold transition-all border shadow-sm ${alwaysShowTaskNames ? 'bg-indigo-50 dark:bg-indigo-900/30 border-indigo-200 dark:border-indigo-800 text-indigo-700 dark:text-indigo-300' : 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-300'}`} title="Toggle Gantt task names visibility">
                                    Names
                                </button>
                            </div>

                            <button onClick={() => setIsDarkMode(!isDarkMode)} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-500 dark:text-slate-400 transition-colors">
                                {isDarkMode ? <Sun className="w-5 h-5" /> : <Moon className="w-5 h-5" />}
                            </button>
                        </div>
                    </header>

                    {/* --- MAIN WORKSPACE --- */}
                    <div id="main-workspace" className="flex flex-1 overflow-hidden bg-slate-50 dark:bg-slate-900 transition-colors relative" ref={exportTargetRef}>

                        {layoutView === 'Gantt' && (
                            <>
                                {/* LEFT PANEL */}
                                <div id="pdf-left-panel" style={{ width: panelWidth }} className="flex-shrink-0 border-r border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 shadow-[4px_0_24px_rgba(0,0,0,0.02)] z-20 relative transition-colors flex flex-col overflow-hidden">
                                    <div className="absolute top-0 right-0 bottom-0 w-1.5 bg-transparent hover:bg-indigo-300 dark:hover:bg-indigo-600 cursor-col-resize z-50" onMouseDown={(e) => { e.preventDefault(); setResizingPanel(true); }} />

                                    <div
                                        className="w-full flex-1 overflow-x-auto overflow-y-auto relative scrollbar-hide"
                                        onScroll={(e) => {
                                            if (timelineContainerRef.current && timelineContainerRef.current.scrollTop !== e.target.scrollTop) {
                                                timelineContainerRef.current.scrollTop = e.target.scrollTop;
                                            }
                                        }}
                                    >
                                        <div id="pdf-left-inner" style={{ minWidth: tableInnerWidth }} className="w-full relative">

                                            {linkingState && linkingState.panel === 'left' && (
                                                <svg className="absolute top-[64px] left-0 w-full h-[calc(100%-64px)] pointer-events-none z-50">
                                                    <path d={`M ${linkingState.startX},${linkingState.startY} C ${linkingState.startX + 50},${linkingState.startY} ${linkingState.currentX - 50},${linkingState.currentY} ${linkingState.currentX},${linkingState.currentY}`} stroke="#6366f1" strokeWidth="2" fill="none" strokeDasharray="4 4" />
                                                    <circle cx={linkingState.currentX} cy={linkingState.currentY} r="4" fill="#6366f1" />
                                                </svg>
                                            )}

                                            <svg className={`absolute top-[64px] left-0 w-full h-[calc(100%-64px)] z-40 overflow-visible link-svg-fade ${activeTaskId ? 'visible' : 'hidden'}`} style={{ pointerEvents: activeTaskId ? 'none' : 'none' }}>
                                                {tasks.map(task => {
                                                    const isTaskHovered = activeTaskId === task.id;
                                                    const hasHoveredDep = task.deps.includes(activeTaskId);
                                                    if (!isTaskHovered && !hasHoveredDep) return null;

                                                    return task.deps.map(depId => {
                                                        if (activeTaskId !== task.id && activeTaskId !== depId) return null;
                                                        const depCoords = taskCoordinates[depId];
                                                        const taskCoords = taskCoordinates[task.id];
                                                        if (!depCoords || !taskCoords) return null;

                                                        const x1 = colWidths.name - 16;
                                                        const y1 = depCoords.y;
                                                        const x2 = colWidths.name - 16;
                                                        const y2 = taskCoords.y;
                                                        const path = `M ${x1},${y1} C ${x1 + 40},${y1} ${x2 + 40},${y2} ${x2},${y2}`;

                                                        return (
                                                            <g key={`lp-${depId}-${task.id}`} className="link-hit-group" onMouseLeave={(e) => { if (e.relatedTarget && e.relatedTarget.closest && e.relatedTarget.closest('.left-task-hitbox, .link-hit-group')) return; setPanelHoveredTask(null); }}>
                                                                <path d={path} stroke="transparent" strokeWidth="14" fill="none" style={{ pointerEvents: 'auto', cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); linkTasks(depId, task.id); }} />
                                                                <path d={path} stroke={isDarkMode ? '#6366f1' : '#4f46e5'} strokeWidth="2" fill="none" style={{ pointerEvents: 'none' }} className="link-visible-path transition-colors" />
                                                            </g>
                                                        );
                                                    });
                                                })}
                                            </svg>

                                            {/* Grid Header */}
                                            <div className="flex items-center h-[64px] bg-slate-50 dark:bg-slate-800/80 backdrop-blur-sm border-b border-slate-200 dark:border-slate-700 text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider sticky top-0 z-30 shadow-sm">
                                                <div className="w-6 flex-shrink-0"></div>
                                                {visibleCols.map(col => (
                                                    <div key={col} style={{ width: colWidths[col] }} className={`${col === 'name' ? 'px-1' : 'px-2'} relative flex items-center flex-shrink-0`}>
                                                        {col === 'name' ? 'Task Name' : col === 'party' ? 'Party' : col === 'duration' ? `Dur (${viewMode === 'Days' ? 'Cal' : viewMode === 'Weeks' ? 'Wks' : 'Bus'})` : col === 'start' ? 'Start Date' : 'End Date'}
                                                        <div className="absolute right-0 top-0 bottom-0 w-2 cursor-col-resize hover:bg-indigo-300 dark:hover:bg-indigo-600 z-10 -mr-1 transition-colors" onMouseDown={(e) => { e.preventDefault(); setResizingCol({ col, startX: e.clientX, startWidth: colWidths[col] }); }} />
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Body */}
                                            {renderPhases.map(rp => {
                                                const phase = rp.phase;
                                                const level = rp.level;
                                                const hasChildren = rp.hasChildren;
                                                const hasItems = hasChildren || (tasksByPhase[phase] && tasksByPhase[phase].length > 0);
                                                const isExpanded = expandedPhases[phase] !== false;
                                                const pBounds = phaseBounds[phase];
                                                let phaseDisplayDur = 0;
                                                if (pBounds) {
                                                    if (viewMode === 'Weeks') {
                                                        const dur = getDurationBetweenDates(pBounds.minS, pBounds.maxE, 'Business');
                                                        phaseDisplayDur = Math.ceil(dur / 5);
                                                    } else if (viewMode === 'Days') {
                                                        phaseDisplayDur = getDurationBetweenDates(pBounds.minS, pBounds.maxE, 'Calendar');
                                                    } else {
                                                        phaseDisplayDur = getDurationBetweenDates(pBounds.minS, pBounds.maxE, 'Business');
                                                    }
                                                }

                                                const isPhaseDragTarget = dragOverTarget?.id === phase && dragOverTarget?.targetType === 'phase';
                                                const isInside = isPhaseDragTarget && dragOverTarget.position === 'inside';
                                                const isBefore = isPhaseDragTarget && dragOverTarget.position === 'before';
                                                const isAfter = isPhaseDragTarget && dragOverTarget.position === 'after';

                                                return (
                                                    <div key={phase} className="mb-0">
                                                        <div
                                                            draggable
                                                            onDragStart={(e) => { e.dataTransfer.setData('type', 'phase'); setDraggedItem({ type: 'phase', id: phase }); }}
                                                            onDragOver={(e) => {
                                                                e.preventDefault();
                                                                const rect = e.currentTarget.getBoundingClientRect();
                                                                const relativeY = e.clientY - rect.top;
                                                                let position = 'inside';
                                                                if (relativeY < rect.height * 0.33) position = 'before';
                                                                else if (relativeY > rect.height * 0.67) position = 'after';
                                                                setDragOverTarget({ id: phase, targetType: 'phase', position });
                                                            }}
                                                            onDragLeave={() => setDragOverTarget(null)}
                                                            onDrop={(e) => handleItemDrop(e, phase, 'phase', phase)}
                                                            className={`flex items-center border-b border-slate-100 dark:border-slate-700/50 group transition-colors cursor-grab ${isBefore ? 'border-t-2 border-t-indigo-500' : ''} ${isAfter ? 'border-b-2 border-b-indigo-500' : ''} ${isInside ? 'bg-indigo-50/10 dark:bg-indigo-900/10' : ''}`}
                                                            style={{ backgroundColor: `${phaseColors[phase] || '#94a3b8'}30`, height: `${rowHeight}px`, fontSize: `${textSize}px` }}
                                                            onClick={() => setExpandedPhases(p => ({ ...p, [phase]: !p[phase] }))}
                                                        >
                                                            <div className="flex-shrink-0 self-stretch" style={{ width: '3px', marginLeft: `${level * 24}px` }}></div>
                                                            <div className="w-5 flex justify-center text-slate-400 flex-shrink-0 relative">
                                                                {hasItems ? (isExpanded ? <ChevronDown className="w-3.5 h-3.5" /> : <ChevronRight className="w-3.5 h-3.5" />) : <div className="w-3.5 h-3.5" />}
                                                            </div>

                                                            <div style={{ width: colWidths.name - (level * 24) - 2 }} className="px-1 flex items-center flex-shrink-0">
                                                                <input type="color" value={phaseColors[phase] || '#94a3b8'} onChange={(e) => { e.stopPropagation(); const val = e.target.value; updateVersion(null, null, prev => ({ ...prev, [phase]: val })); }} onClick={(e) => e.stopPropagation()} className="w-3.5 h-3.5 p-0 border-0 rounded cursor-pointer mr-1.5 bg-transparent shadow-sm flex-shrink-0" />
                                                                {editingPhase && editingPhase.oldName === phase ? (
                                                                    <input
                                                                        autoFocus
                                                                        type="text"
                                                                        value={editingPhase.tempName}
                                                                        onClick={e => e.stopPropagation()}
                                                                        onChange={e => setEditingPhase({ ...editingPhase, tempName: e.target.value })}
                                                                        onKeyDown={e => {
                                                                            if (e.key === 'Enter') {
                                                                                e.preventDefault();
                                                                                e.stopPropagation();
                                                                                handleRenamePhaseSubmit();
                                                                            } else if (e.key === 'Escape') {
                                                                                setEditingPhase(null);
                                                                            }
                                                                        }}
                                                                        onBlur={handleRenamePhaseSubmit}
                                                                        className="font-bold text-sm text-slate-900 dark:text-slate-100 bg-white dark:bg-slate-900 border border-indigo-500 rounded px-1 -ml-1 outline-none w-full max-w-[150px]"
                                                                    />
                                                                ) : (
                                                                    <span
                                                                        className="font-bold text-sm text-slate-800 dark:text-slate-200 truncate pr-1 cursor-text hover:text-indigo-600 dark:hover:text-indigo-400"
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            setEditingPhase({ oldName: phase, tempName: phase });
                                                                        }}
                                                                    >
                                                                        {phase}
                                                                    </span>
                                                                )}
                                                                <button onClick={(e) => { e.stopPropagation(); handleDeletePhase(phase); }} className="opacity-0 group-hover:opacity-100 p-0.5 hover:bg-red-100 hover:text-red-600 dark:hover:bg-red-900/30 dark:hover:text-red-400 rounded transition-all ml-auto"><Trash2 className="w-3 h-3" /></button>
                                                                <button onClick={(e) => { e.stopPropagation(); addTask(phase); setExpandedPhases(p => ({ ...p, [phase]: true })); }} className="opacity-0 group-hover:opacity-100 p-0.5 bg-indigo-50 dark:bg-indigo-900/50 hover:bg-indigo-100 dark:hover:bg-indigo-800 text-indigo-600 dark:text-indigo-400 rounded transition-all ml-0.5"><Plus className="w-3 h-3" /></button>
                                                            </div>

                                                            {columnVisibility.party && <div style={{ width: colWidths.party }} className="px-1 flex-shrink-0"></div>}
                                                            {columnVisibility.duration && <div style={{ width: colWidths.duration }} className="px-1 flex-shrink-0">
                                                                <div className="relative w-full flex items-center justify-center text-xs font-semibold text-slate-500 dark:text-slate-400 py-0.5 rounded" style={{ backgroundColor: `${phaseColors[phase] || '#94a3b8'}20` }}>
                                                                    <span className="pr-3 text-center">{phaseDisplayDur}</span>
                                                                    <span className="absolute right-2 text-[10px] font-medium text-slate-400">{viewMode === 'Weeks' ? 'w' : 'd'}</span>
                                                                </div>
                                                            </div>}
                                                            {columnVisibility.start && <div style={{ width: colWidths.start }} className="px-1 pr-2 flex-shrink-0 text-xs font-semibold text-slate-400">{pBounds ? formatShortDate(pBounds.minS) : ''}</div>}
                                                            {columnVisibility.end && <div style={{ width: colWidths.end }} className="px-1 pr-2 flex-shrink-0 text-xs font-semibold text-slate-400">{pBounds ? formatShortDate(pBounds.maxE) : ''}</div>}
                                                        </div>

                                                        {isExpanded && tasksByPhase[phase] && tasksByPhase[phase].map(task => {
                                                            const taskWarning = isNonWorkingDay(task.start, durationType);
                                                            const endDateStr = calculateEndDate(task.start, task.duration, durationType);
                                                            let displayDur = task.duration;
                                                            if (viewMode === 'Weeks') {
                                                                displayDur = Math.ceil(task.duration / 5);
                                                            } else if (viewMode === 'Days') {
                                                                displayDur = getDurationBetweenDates(task.start, endDateStr, 'Calendar');
                                                            }

                                                            const mType = task.milestone || 0;
                                                            const flagColor = mType === 2 ? 'text-emerald-500 bg-emerald-50 dark:bg-emerald-900/20' : mType === 1 ? 'text-amber-500 bg-amber-50 dark:bg-amber-900/20' : 'text-slate-300 dark:text-slate-600 hover:text-slate-500 opacity-0 group-hover:opacity-100';
                                                            const nameColor = mType === 2 ? 'font-extrabold text-emerald-700 dark:text-emerald-400' : mType === 1 ? 'font-bold text-slate-900 dark:text-slate-100' : 'font-medium text-slate-700 dark:text-slate-300';

                                                            const isTaskDragTarget = dragOverTarget?.id === task.id;
                                                            const isTaskBefore = isTaskDragTarget && dragOverTarget.position === 'before';
                                                            const isTaskAfter = isTaskDragTarget && dragOverTarget.position === 'after';

                                                            return (
                                                                <div
                                                                    key={task.id}
                                                                    draggable
                                                                    onDragStart={(e) => { e.dataTransfer.setData('type', 'task'); setDraggedItem({ type: 'task', id: task.id }); }}
                                                                    onDragOver={(e) => {
                                                                        e.preventDefault();
                                                                        const rect = e.currentTarget.getBoundingClientRect();
                                                                        const relativeY = e.clientY - rect.top;
                                                                        const position = relativeY < rect.height * 0.5 ? 'before' : 'after';
                                                                        setDragOverTarget({ id: task.id, targetType: 'task', position, phase });
                                                                    }}
                                                                    onDragLeave={() => setDragOverTarget(null)}
                                                                    onDrop={(e) => {
                                                                        if (draggedItem?.type === 'phase') {
                                                                            handleItemDrop(e, task.id, 'task', phase);
                                                                        } else {
                                                                            handleItemDrop(e, task.id, 'task', phase);
                                                                        }
                                                                    }}
                                                                    onMouseEnter={() => setPanelHoveredTask(task.id)}
                                                                    onMouseLeave={(e) => { if (e.relatedTarget && e.relatedTarget.closest && e.relatedTarget.closest('.link-hit-group')) return; setPanelHoveredTask(null); }}
                                                                    onFocus={(e) => setFocusedTask(task.id)}
                                                                    onBlur={(e) => { if (!e.currentTarget.contains(e.relatedTarget)) setFocusedTask(null); }}
                                                                    className={`flex items-center border-b border-slate-50 dark:border-slate-700/30 group text-sm transition-colors cursor-grab left-task-hitbox ${isTaskBefore ? 'border-t-2 border-t-indigo-500' : ''} ${isTaskAfter ? 'border-b-2 border-b-indigo-500' : ''} ${activeTaskId === task.id ? 'bg-indigo-50 dark:bg-indigo-900/40' : 'hover:bg-indigo-50/50 dark:hover:bg-indigo-900/50'}`}
                                                                    style={{ height: `${rowHeight}px`, fontSize: `${textSize}px` }}
                                                                    data-taskid={task.id}
                                                                >
                                                                    <div className="flex-shrink-0 self-stretch" style={{ width: '3px', marginLeft: `${level * 24}px` }}></div>
                                                                    <div className="w-5 flex items-center justify-center flex-shrink-0 relative">
                                                                        <button onClick={() => deleteTask(task.id)} className="opacity-0 group-hover:opacity-100 text-slate-300 dark:text-slate-500 hover:text-red-500 dark:hover:text-red-400 transition-opacity absolute ml-6 z-10 bg-white dark:bg-slate-800 rounded shadow-sm p-0.5 border border-slate-100 dark:border-slate-700"><Trash2 className="w-3.5 h-3.5" /></button>
                                                                    </div>
                                                                    <div style={{ width: colWidths.name - (level * 24) - 2 }} className="px-1 flex-shrink-0 relative">
                                                                        <div className="flex items-center pl-1 pr-1">
                                                                            <button onClick={() => cycleMilestone(task.id)} className={`flex-shrink-0 p-0.5 rounded-md transition-colors ${flagColor}`} title="Toggle Milestone"><Flag className="w-3.5 h-3.5" /></button>
                                                                            <input type="text" value={task.name} onChange={(e) => handleTaskChange(task.id, 'name', e.target.value)} className={`w-full bg-transparent border-none focus:ring-1 focus:ring-indigo-500 focus:bg-white dark:focus:bg-slate-900 rounded px-1 py-1 transition-all ${nameColor}`} />
                                                                        </div>
                                                                        {activeTaskId === task.id && (
                                                                            <div className="absolute top-1/2 -translate-y-1/2 right-2 h-4 w-4 bg-white dark:bg-slate-800 border-2 border-indigo-500 rounded-full z-40 cursor-crosshair shadow-sm flex items-center justify-center transition-opacity" onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); const container = document.getElementById('pdf-left-panel').querySelector('.overflow-y-auto'); const rect = container.getBoundingClientRect(); const startX = e.clientX - rect.left + container.scrollLeft; const startY = (e.clientY - rect.top + container.scrollTop) - 64; setLinkingState({ sourceId: task.id, startX, startY, currentX: startX, currentY: startY, panel: 'left' }); }} title="Drag to link to another task">
                                                                                <div className="w-1.5 h-1.5 bg-indigo-500 rounded-full"></div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    {columnVisibility.party && <div style={{ width: colWidths.party }} className="px-1 flex-shrink-0">
                                                                        <select value={task.party} onChange={(e) => handleTaskChange(task.id, 'party', e.target.value)} className={`w-full bg-transparent border-none focus:ring-1 focus:ring-indigo-500 focus:bg-white dark:focus:bg-slate-900 rounded text-xs cursor-pointer ${mType === 2 ? 'font-extrabold text-emerald-700 dark:text-emerald-400' : mType === 1 ? 'font-bold text-slate-900 dark:text-slate-100' : 'font-medium text-slate-500 dark:text-slate-400'}`}>
                                                                            <option value=""></option>
                                                                            <option value="All">All</option>
                                                                            {PARTIES.map(p => <option key={p} value={p}>{p}</option>)}
                                                                        </select>
                                                                    </div>}
                                                                    {columnVisibility.duration && <div style={{ width: colWidths.duration }} className="px-1 flex-shrink-0">
                                                                        <div className="relative w-full flex items-center justify-center">
                                                                            <input type="number" min="0" value={displayDur} onChange={(e) => {
                                                                                let raw = parseInt(e.target.value) || 0;
                                                                                let engineDur = raw;
                                                                                if (viewMode === 'Weeks') engineDur = Math.max(1, raw * 5);
                                                                                else if (viewMode === 'Days') {
                                                                                    const calEnd = calculateEndDate(task.start, Math.max(1, raw), 'Calendar');
                                                                                    engineDur = getDurationBetweenDates(task.start, calEnd, 'Business');
                                                                                }
                                                                                handleTaskChange(task.id, 'duration', engineDur);
                                                                            }} disabled={mType > 0} className={`w-full text-center bg-transparent border border-transparent hover:border-slate-200 dark:hover:border-slate-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:bg-white dark:focus:bg-slate-900 rounded py-1 pr-3 disabled:opacity-50 ${mType > 0 ? 'font-extrabold' : 'font-semibold'} [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none ${mType === 2 ? 'text-emerald-700 dark:text-emerald-400' : mType === 1 ? 'text-slate-900 dark:text-slate-100' : 'text-slate-700 dark:text-slate-200'}`} />
                                                                            <span className="absolute right-2 text-[10px] font-medium text-slate-400 pointer-events-none">{viewMode === 'Weeks' ? 'w' : 'd'}</span>
                                                                        </div>
                                                                    </div>}
                                                                    {columnVisibility.start && <div style={{ width: colWidths.start }} className="px-1 pr-2 flex-shrink-0 relative flex items-center group/date">
                                                                        <input type="text" value={formatShortDate(task.start)} onChange={(e) => { const iso = parseShortDate(e.target.value); if (iso) handleTaskChange(task.id, 'start', iso); }} onBlur={(e) => { const iso = parseShortDate(e.target.value); if (!iso) e.target.value = formatShortDate(task.start); }} placeholder="MM/DD/YY" className={`w-full bg-transparent border border-transparent hover:border-slate-200 dark:hover:border-slate-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:bg-white dark:focus:bg-slate-900 rounded text-xs py-1 transition-colors cursor-text ${taskWarning ? 'text-red-600 dark:text-red-400 font-bold' : mType === 2 ? 'text-emerald-700 dark:text-emerald-400 font-extrabold' : mType === 1 ? 'text-slate-900 dark:text-slate-100 font-bold' : 'text-slate-600 dark:text-slate-300 font-medium'}`} />
                                                                        {taskWarning && <AlertCircle className="w-3.5 h-3.5 text-red-500 absolute right-6 top-1.5 pointer-events-none" title="Starts on a Non-Working Day" />}
                                                                        <div className="absolute right-1 top-1.5 opacity-0 group-hover/date:opacity-100 transition-opacity">
                                                                            <Calendar className="w-4 h-4 text-slate-400 hover:text-indigo-500 transition-colors" />
                                                                            <input type="date" value={task.start} onChange={(e) => e.target.value && handleTaskChange(task.id, 'start', e.target.value)} onClick={(e) => e.stopPropagation()} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" />
                                                                        </div>
                                                                    </div>}
                                                                    {columnVisibility.end && <div style={{ width: colWidths.end }} className="px-1 pr-2 flex-shrink-0 relative flex items-center group/date">
                                                                        <input type="text" value={formatShortDate(endDateStr)} onChange={(e) => { const iso = parseShortDate(e.target.value); if (iso) handleTaskChange(task.id, 'duration', getDurationBetweenDates(task.start, iso, durationType)); }} onBlur={(e) => { const iso = parseShortDate(e.target.value); if (!iso) e.target.value = formatShortDate(endDateStr); }} placeholder="MM/DD/YY" disabled={mType > 0} className={`w-full bg-transparent border border-transparent hover:border-slate-200 dark:hover:border-slate-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:bg-white dark:focus:bg-slate-900 rounded text-xs py-1 transition-colors cursor-text ${mType === 2 ? 'text-emerald-700 dark:text-emerald-400 font-extrabold' : mType === 1 ? 'text-slate-900 dark:text-slate-100 font-bold' : 'text-slate-600 dark:text-slate-300 font-medium'} disabled:opacity-50`} />
                                                                        {mType === 0 && (
                                                                            <div className="absolute right-1 top-1.5 opacity-0 group-hover/date:opacity-100 transition-opacity">
                                                                                <Calendar className="w-4 h-4 text-slate-400 hover:text-indigo-500 transition-colors" />
                                                                                <input type="date" value={endDateStr} onChange={(e) => e.target.value && handleTaskChange(task.id, 'duration', getDurationBetweenDates(task.start, e.target.value, durationType))} onClick={(e) => e.stopPropagation()} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" />
                                                                            </div>
                                                                        )}
                                                                    </div>}
                                                                </div>
                                                            )
                                                        })}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>

                                    <div className="p-3 border-t border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] transition-colors w-full">
                                        <form onSubmit={(e) => { e.preventDefault(); const p = newPhaseName.trim(); if (p && !phases.includes(p)) { updateVersion(null, prev => [...prev, p], prevColors => ({ ...prevColors, [p]: '#64748b' })); setExpandedPhases({ ...expandedPhases, [p]: true }); setNewPhaseName(''); } }} className="flex items-center space-x-2">
                                            <input type="text" value={newPhaseName} onChange={(e) => setNewPhaseName(e.target.value)} placeholder="Create a new phase..." className="flex-1 bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 text-sm font-medium rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all text-slate-800 dark:text-slate-100" />
                                            <button type="submit" className="bg-indigo-50 dark:bg-indigo-900/50 hover:bg-indigo-100 dark:hover:bg-indigo-800 text-indigo-600 dark:text-indigo-400 font-bold p-2 rounded-md transition-colors"><Plus className="w-5 h-5" /></button>
                                        </form>
                                    </div>
                                </div>

                                {/* RIGHT PANEL: Gantt Chart */}
                                <div className="flex-1 flex flex-col overflow-hidden bg-white dark:bg-slate-900 transition-colors">
                                    <div
                                        id="timeline-container"
                                        className="flex-1 overflow-auto relative"
                                        ref={timelineContainerRef}
                                        onScroll={(e) => {
                                            const leftPanel = e.target.parentElement?.previousElementSibling?.querySelector('.overflow-y-auto');
                                            if (leftPanel && leftPanel.scrollTop !== e.target.scrollTop) {
                                                leftPanel.scrollTop = e.target.scrollTop;
                                            }
                                        }}
                                    >
                                        <div id="pdf-right-inner" style={{ width: `${totalDays * dayWidth}px`, minHeight: '100%' }} className="relative">
                                            <div className="sticky top-0 z-40 bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700 shadow-sm transition-colors">
                                                <div className="h-8 relative border-b border-slate-100 dark:border-slate-700/50 bg-slate-50 dark:bg-slate-800/80">
                                                    {timelineHeaders.months.map((m, i) => (
                                                        <div key={i} className="absolute top-0 bottom-0 px-2 py-1 text-xs font-bold text-slate-800 dark:text-slate-200 border-l-2 border-slate-400 dark:border-slate-500 overflow-hidden whitespace-nowrap" style={{ left: `${m.start * dayWidth}px`, width: `${m.width * dayWidth}px`, marginLeft: i === 0 ? 0 : '-1px' }}>
                                                            {m.name}
                                                        </div>
                                                    ))}
                                                </div>
                                                <div className="h-8 relative bg-white dark:bg-slate-800 overflow-hidden">
                                                    {timelineHeaders.weeks.map((w, i) => (
                                                        <div key={i} className="absolute top-0 bottom-0 text-[10px] font-semibold text-slate-500 dark:text-slate-400 px-1.5 border-l border-slate-300 dark:border-slate-600 flex items-center group" style={{ left: `${w.dayOffset * dayWidth}px`, width: `${7 * dayWidth}px` }}>
                                                            {dayWidth > 10 ? `${w.date.getUTCDate()} ${w.date.toLocaleString('default', { month: 'short', timeZone: 'UTC' })}` : ''}
                                                            <div className="absolute right-0 top-0 bottom-0 w-2 cursor-col-resize hover:bg-indigo-400 dark:hover:bg-indigo-500 z-50 -mr-1 opacity-0 group-hover:opacity-100 transition-opacity" onMouseDown={(e) => { e.preventDefault(); setResizingTimeline({ startX: e.clientX, startDayWidth: dayWidth }); }} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>

                                            <div className="absolute top-16 left-0 right-0 bottom-0 pointer-events-none">
                                                {timelineHeaders.days.map((d, i) => {
                                                    let bg = 'bg-transparent';
                                                    if (d.isHoliday) bg = 'bg-rose-50/60 dark:bg-rose-900/20';
                                                    else if (d.isWeekend) bg = 'bg-slate-50/80 dark:bg-slate-800/50';
                                                    const isStartOfWeek = d.date.getUTCDay() === 1;
                                                    const isStartOfMonth = d.date.getUTCDate() === 1;
                                                    let borderClass = 'border-l border-slate-100 dark:border-slate-800/50';
                                                    if (isStartOfMonth) borderClass = 'border-l-2 border-slate-400 dark:border-slate-500 z-10 relative';
                                                    else if (isStartOfWeek) borderClass = 'border-l border-slate-300 dark:border-slate-600';
                                                    return (
                                                        <div key={i} className={`absolute top-0 bottom-0 ${borderClass} ${bg}`} style={{ left: `${i * dayWidth}px`, width: `${dayWidth}px`, marginLeft: (isStartOfMonth && i !== 0) ? '-1px' : '0' }}>
                                                            {dayWidth > 30 && <div className="text-[9px] text-slate-300 dark:text-slate-600 text-center mt-1 font-medium">{d.date.getUTCDate()}</div>}
                                                        </div>
                                                    )
                                                })}
                                                {/* Current Day Line */}
                                                {showTodayLine && (
                                                    <div className="absolute top-0 bottom-0 w-[2px] bg-red-500/80 dark:bg-red-500/80 z-40 transition-colors" style={{ left: `${todayOffsetDays * dayWidth}px` }} title="Today" />
                                                )}
                                            </div>

                                            {linkingState && (
                                                <svg className="absolute top-[64px] left-0 w-full h-[calc(100%-64px)] pointer-events-none z-50">
                                                    <path d={`M ${linkingState.startX},${linkingState.startY} C ${linkingState.startX + 50},${linkingState.startY} ${linkingState.currentX - 50},${linkingState.currentY} ${linkingState.currentX},${linkingState.currentY}`} stroke="#6366f1" strokeWidth="2" fill="none" strokeDasharray="4 4" />
                                                    <circle cx={linkingState.currentX} cy={linkingState.currentY} r="4" fill="#6366f1" />
                                                </svg>
                                            )}

                                            <svg className="absolute top-[64px] left-0 w-full h-[calc(100%-64px)] pointer-events-none z-10">
                                                {tasks.map(task => task.deps.map(depId => {
                                                    const depCoords = taskCoordinates[depId];
                                                    const taskCoords = taskCoordinates[task.id];
                                                    if (!depCoords || !taskCoords) return null;
                                                    const x1 = depCoords.endX; const y1 = depCoords.y;
                                                    const x2 = taskCoords.startX; const y2 = taskCoords.y;
                                                    const path = `M ${x1},${y1} C ${x1 + 15},${y1} ${x2 - 15},${y2} ${x2},${y2}`;
                                                    return (
                                                        <g key={`${depId}-${task.id}`} className="link-hit-group">
                                                            <path d={path} stroke="transparent" strokeWidth="14" fill="none" style={{ pointerEvents: 'auto', cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); linkTasks(depId, task.id); }} />
                                                            <path d={path} stroke={isDarkMode ? '#475569' : '#cbd5e1'} strokeWidth="2" fill="none" style={{ pointerEvents: 'none' }} className="link-visible-path transition-colors" />
                                                        </g>
                                                    );
                                                }))}
                                            </svg>

                                            <div className="pt-0">
                                                {renderPhases.map(rp => {
                                                    const phase = rp.phase;
                                                    const isExpanded = expandedPhases[phase] !== false;
                                                    const pBounds = phaseBounds[phase];

                                                    const isPhaseDragTarget = dragOverTarget?.id === phase && dragOverTarget?.targetType === 'phase';
                                                    const isInside = isPhaseDragTarget && dragOverTarget.position === 'inside';
                                                    const isBefore = isPhaseDragTarget && dragOverTarget.position === 'before';
                                                    const isAfter = isPhaseDragTarget && dragOverTarget.position === 'after';

                                                    return (
                                                        <div
                                                            key={phase}
                                                            className={`mb-0 ${isBefore ? 'border-t-2 border-t-indigo-500' : ''} ${isAfter ? 'border-b-2 border-b-indigo-500' : ''} ${isInside ? 'bg-indigo-50/10 dark:bg-indigo-900/10' : ''}`}
                                                            draggable
                                                            onDragStart={(e) => { e.dataTransfer.setData('type', 'phase'); setDraggedItem({ type: 'phase', id: phase }); }}
                                                            onDragOver={(e) => {
                                                                e.preventDefault();
                                                                const rect = e.currentTarget.getBoundingClientRect();
                                                                const relativeY = e.clientY - rect.top;
                                                                let position = 'inside';
                                                                if (relativeY < rect.height * 0.33) position = 'before';
                                                                else if (relativeY > rect.height * 0.67) position = 'after';
                                                                setDragOverTarget({ id: phase, targetType: 'phase', position });
                                                            }}
                                                            onDragLeave={() => setDragOverTarget(null)}
                                                            onDrop={(e) => handleItemDrop(e, phase, 'phase', phase)}
                                                        >
                                                            <div style={{ height: `${rowHeight}px` }} className="border-b border-slate-100 dark:border-slate-800 relative flex items-center hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors">
                                                                {pBounds && (
                                                                    <div
                                                                        className={`absolute h-1.5 rounded-full ${dragPhaseState?.phase === phase ? 'opacity-90 dark:opacity-80' : 'opacity-60 dark:opacity-40'} cursor-move hover:h-2 transition-all`}
                                                                        style={{
                                                                            left: `${(pBounds.offStart + (dragPhaseState?.phase === phase ? dragPhaseState.currentDelta : 0)) * dayWidth}px`,
                                                                            width: `${pBounds.width}px`,
                                                                            backgroundColor: phaseColors[phase] || '#94a3b8'
                                                                        }}
                                                                        onMouseDown={(e) => {
                                                                            e.preventDefault();
                                                                            e.stopPropagation();
                                                                            setDragPhaseState({ phase: phase, startX: e.clientX, currentDelta: 0 });
                                                                        }}
                                                                        title="Drag to shift entire phase"
                                                                    />
                                                                )}
                                                            </div>
                                                            {isExpanded && tasksByPhase[phase] && tasksByPhase[phase].map(task => {
                                                                const mType = task.milestone || 0;
                                                                const isMilestone = mType > 0;
                                                                const endDateStr = calculateEndDate(task.start, task.duration, durationType);
                                                                const color = task.color || phaseColors[task.phase] || '#94a3b8';
                                                                let displayDur = task.duration;
                                                                if (viewMode === 'Weeks') {
                                                                    displayDur = Math.ceil(task.duration / 5);
                                                                } else if (viewMode === 'Days') {
                                                                    displayDur = getDurationBetweenDates(task.start, endDateStr, 'Calendar');
                                                                }

                                                                let segments = [];
                                                                if (viewMode === 'Business' && !isMilestone) {
                                                                    let currentSegStart = null;
                                                                    let current = parseDate(task.start);
                                                                    const endD = parseDate(endDateStr);
                                                                    while (current <= endD) {
                                                                        const dStr = current.toISOString().split('T')[0];
                                                                        if (!isNonWorkingDay(dStr, 'Business')) {
                                                                            if (!currentSegStart) currentSegStart = dStr;
                                                                        } else {
                                                                            if (currentSegStart) { segments.push({ start: currentSegStart, end: addDays(dStr, -1) }); currentSegStart = null; }
                                                                        }
                                                                        current.setUTCDate(current.getUTCDate() + 1);
                                                                    }
                                                                    if (currentSegStart) segments.push({ start: currentSegStart, end: endDateStr });
                                                                } else {
                                                                    segments.push({ start: task.start, end: endDateStr });
                                                                }

                                                                const msClass = mType === 2 ? 'bg-emerald-500 border-emerald-200 dark:border-emerald-900' : 'bg-amber-400 border-white dark:border-slate-900';
                                                                const labelClass = mType === 2 ? 'font-extrabold text-emerald-700 dark:text-emerald-400' : mType === 1 ? 'font-bold text-slate-800 dark:text-slate-200' : 'font-bold text-slate-700 dark:text-slate-200';

                                                                const isRtTaskDragTarget = dragOverTarget?.id === task.id;
                                                                const isRtTaskBefore = isRtTaskDragTarget && dragOverTarget.position === 'before';
                                                                const isRtTaskAfter = isRtTaskDragTarget && dragOverTarget.position === 'after';

                                                                return (
                                                                    <div
                                                                        key={task.id}
                                                                        draggable
                                                                        onDragStart={(e) => { e.dataTransfer.setData('type', 'task'); setDraggedItem({ type: 'task', id: task.id }); }}
                                                                        onDragOver={(e) => {
                                                                            e.preventDefault();
                                                                            const rect = e.currentTarget.getBoundingClientRect();
                                                                            const relativeY = e.clientY - rect.top;
                                                                            const position = relativeY < rect.height * 0.5 ? 'before' : 'after';
                                                                            setDragOverTarget({ id: task.id, targetType: 'task', position, phase });
                                                                        }}
                                                                        onDragLeave={() => setDragOverTarget(null)}
                                                                        onDrop={(e) => handleItemDrop(e, task.id, 'task', phase)}
                                                                        onMouseEnter={() => setPanelHoveredTask(task.id)}
                                                                        onMouseLeave={(e) => { if (e.relatedTarget && e.relatedTarget.closest && e.relatedTarget.closest('.link-hit-group')) return; setPanelHoveredTask(null); }}
                                                                        className={`relative flex items-center group border-b border-transparent task-bar-hitbox transition-colors cursor-grab ${isRtTaskBefore ? 'border-t-2 border-t-indigo-500' : ''} ${isRtTaskAfter ? 'border-b-2 border-b-indigo-500' : ''} ${activeTaskId === task.id ? 'bg-indigo-50/60 dark:bg-indigo-900/40' : 'hover:bg-slate-100 dark:hover:bg-slate-800'}`}
                                                                        style={{ height: `${rowHeight}px` }}
                                                                        data-taskid={task.id}
                                                                        onContextMenu={(e) => handleContextMenu(e, task.id)}
                                                                    >
                                                                        {segments.length > 1 && (
                                                                            <div className="absolute h-6 rounded-md opacity-20 dark:opacity-30 pointer-events-none" style={{ left: `${diffDays(timelineBounds.start.toISOString().split('T')[0], segments[0].start) * dayWidth}px`, width: `${(diffDays(timelineBounds.start.toISOString().split('T')[0], segments[segments.length - 1].end) - diffDays(timelineBounds.start.toISOString().split('T')[0], segments[0].start) + 1) * dayWidth}px`, backgroundColor: color }} />
                                                                        )}
                                                                        {segments.map((seg, i) => {
                                                                            const segOffsetDays = diffDays(timelineBounds.start.toISOString().split('T')[0], seg.start);
                                                                            const segEndOffsetDays = diffDays(timelineBounds.start.toISOString().split('T')[0], seg.end);
                                                                            const segLeftPos = isMilestone ? (segOffsetDays * dayWidth) + (dayWidth / 2) - 10 : segOffsetDays * dayWidth;
                                                                            const segBarWidth = isMilestone ? 20 : (segEndOffsetDays - segOffsetDays + 1) * dayWidth;
                                                                            const isFirst = i === 0; const isLast = i === segments.length - 1;

                                                                            return (
                                                                                <React.Fragment key={`${task.id}-seg-${i}`}>
                                                                                    {isFirst && !isMilestone && <div className="absolute h-6 w-3 z-30 cursor-w-resize -ml-1.5 opacity-0 group-hover:opacity-100" style={{ left: `${segLeftPos}px` }} onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); setDragTaskState({ type: 'left', taskId: task.id, startX: e.clientX, originalStartStr: task.start, originalEndStr: endDateStr, currentStartStr: task.start, currentDuration: task.duration }); }} />}

                                                                                    {dragTaskState && dragTaskState.taskId === task.id && dragTaskState.type === 'left' && isFirst && (
                                                                                        <div className="absolute z-50 transform -translate-x-1/2 -translate-y-9 bg-indigo-600 dark:bg-indigo-500 text-white text-[10px] font-bold px-2.5 py-1 rounded shadow-md whitespace-nowrap pointer-events-none flex flex-col items-center" style={{ left: `${segLeftPos}px` }}>
                                                                                            <span>{formatShortDate(task.start)}</span>
                                                                                            <div className="w-0 h-0 border-l-[4px] border-r-[4px] border-t-[4px] border-transparent border-t-indigo-600 dark:border-t-indigo-500 absolute -bottom-[4px]"></div>
                                                                                        </div>
                                                                                    )}

                                                                                    <div onContextMenu={(e) => handleContextMenu(e, task.id)} onMouseDown={(e) => { e.preventDefault(); setDragTaskState({ type: 'center', taskId: task.id, startX: e.clientX, originalStartStr: task.start, currentStartStr: task.start }); }} className={`absolute flex items-center justify-center shadow-sm cursor-move transition-all hover:brightness-110 z-20 ${isMilestone ? `h-5 w-5 rotate-45 border-2 ${msClass}` : 'h-6 rounded-md border border-black/10 dark:border-white/10'}`} style={{ left: `${segLeftPos}px`, width: `${segBarWidth}px`, backgroundColor: isMilestone ? (task.color || undefined) : color }} />

                                                                                    {isLast && !isMilestone && <div className="absolute h-6 w-3 z-30 cursor-e-resize -mr-1.5 opacity-0 group-hover:opacity-100" style={{ left: `${segLeftPos + segBarWidth}px` }} onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); setDragTaskState({ type: 'right', taskId: task.id, startX: e.clientX, originalStartStr: task.start, originalEndStr: endDateStr, currentDuration: task.duration }); }} />}

                                                                                    {dragTaskState && dragTaskState.taskId === task.id && dragTaskState.type === 'right' && isLast && (
                                                                                        <div className="absolute z-50 transform -translate-x-1/2 -translate-y-9 bg-indigo-600 dark:bg-indigo-500 text-white text-[10px] font-bold px-2.5 py-1 rounded shadow-md whitespace-nowrap pointer-events-none flex flex-col items-center" style={{ left: `${segLeftPos + segBarWidth}px` }}>
                                                                                            <span>{formatShortDate(endDateStr)}</span>
                                                                                            <div className="w-0 h-0 border-l-[4px] border-r-[4px] border-t-[4px] border-transparent border-t-indigo-600 dark:border-t-indigo-500 absolute -bottom-[4px]"></div>
                                                                                        </div>
                                                                                    )}

                                                                                    {isLast && (
                                                                                        <div className="absolute h-4 w-4 bg-white dark:bg-slate-800 border-2 border-indigo-500 rounded-full z-40 cursor-crosshair opacity-0 group-hover:opacity-100 shadow-sm flex items-center justify-center transition-opacity" style={{ left: `${segLeftPos + segBarWidth + 6}px` }} onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); const container = timelineContainerRef.current; const rect = container.getBoundingClientRect(); const startX = e.clientX - rect.left + container.scrollLeft; const startY = (e.clientY - rect.top + container.scrollTop) - 64; setLinkingState({ sourceId: task.id, startX, startY, currentX: startX, currentY: startY }); }} title="Drag to link to another task">
                                                                                            <div className="w-1.5 h-1.5 bg-indigo-500 rounded-full"></div>
                                                                                        </div>
                                                                                    )}
                                                                                    {isLast && (
                                                                                        <div className={`absolute whitespace-nowrap text-xs z-20 pointer-events-none transition-opacity ${alwaysShowTaskNames ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} ${labelClass}`} style={{ left: `${segLeftPos + (isMilestone ? 32 : segBarWidth + 28)}px` }}>
                                                                                            <span className="bg-white/95 dark:bg-slate-800/95 px-2 py-1 rounded-md shadow-sm border border-slate-200 dark:border-slate-700 backdrop-blur-sm">
                                                                                                {task.name} {!isMilestone && `(${displayDur}${viewMode === 'Weeks' ? 'W' : viewMode === 'Days' ? 'c' : 'b'})`}
                                                                                            </span>
                                                                                        </div>
                                                                                    )}
                                                                                </React.Fragment>
                                                                            )
                                                                        })}
                                                                    </div>
                                                                )
                                                            })}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Invisible matching footer to sync scroll heights perfectly with left pane */}
                                    <div className="p-3 border-t border-transparent w-full pointer-events-none opacity-0" aria-hidden="true">
                                        <div className="flex items-center space-x-2">
                                            <div className="flex-1 px-3 py-2 text-sm border border-transparent"></div>
                                            <div className="p-2 border border-transparent"><Plus className="w-5 h-5" /></div>
                                        </div>
                                    </div>
                                </div>
                            </>
                        )}

                        {/* --- TIMELINE VIEW --- */}
                        {layoutView === 'Timeline' && (
                            <div id="pdf-timeline-view" className="flex-1 w-full h-full overflow-auto bg-slate-50 dark:bg-slate-900 p-8 flex flex-col items-center relative">
                                <div id="pdf-timeline-inner" className="w-full max-w-5xl bg-white dark:bg-slate-800 rounded-2xl shadow-sm border border-slate-200 dark:border-slate-700 p-8">
                                    <h2 className="text-2xl font-bold text-slate-800 dark:text-white mb-12 text-center">{activeProject.name} - {activeVersion.name}</h2>

                                    <div className="relative w-full pt-36 pb-16 px-4">
                                        {/* Timeline Bar & Date Markers */}
                                        <div className="absolute top-32 left-0 right-0">
                                            <div className="absolute top-0 left-0 right-0 h-1.5 bg-slate-200 dark:bg-slate-700 rounded-full shadow-inner" />
                                            {/* Week Markers */}
                                            {timelineHeaders.weeks.map((w, i) => (
                                                <div key={`w-${i}`} className="absolute top-0 w-[2px] h-2.5 bg-slate-300 dark:bg-slate-600 -mt-[2px] rounded-full" style={{ left: `${(w.dayOffset / totalDays) * 100}%` }} title={`Week of ${formatShortDate(w.date.toISOString().split('T')[0])}`} />
                                            ))}
                                            {/* Month Markers & Labels */}
                                            {timelineHeaders.months.map((m, i) => {
                                                const percent = (m.start / totalDays) * 100;
                                                const nameParts = m.name.split(' ');
                                                const shortName = nameParts[0].substring(0, 3) + (nameParts.length > 1 ? ` '${nameParts[1].substring(2)}` : '');
                                                return (
                                                    <div key={`m-${i}`} className="absolute top-0 flex flex-col items-center z-10" style={{ left: `${percent}%` }}>
                                                        <div className="w-[3px] h-4 bg-slate-400 dark:bg-slate-500 -mt-[5px] rounded-full shadow-sm" />
                                                        <span className="text-[10px] sm:text-xs font-bold text-slate-500 dark:text-slate-400 mt-2 absolute top-4 whitespace-nowrap bg-white/80 dark:bg-slate-800/80 px-1.5 py-0.5 rounded backdrop-blur-sm shadow-sm border border-white/40 dark:border-slate-700/40">{shortName}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>

                                        {/* Milestones Top */}
                                        {filteredTasks.filter(t => t.milestone > 0).map((m, i) => {
                                            const offsetDays = diffDays(timelineBounds.start.toISOString().split('T')[0], m.start);
                                            const percent = Math.max(0, Math.min(100, (offsetDays / totalDays) * 100));
                                            const isOwner = m.milestone === 2;
                                            const colorClass = m.color ? '' : (isOwner ? 'bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 border-emerald-200 dark:border-emerald-800' : 'bg-amber-50 dark:bg-amber-900/30 text-amber-800 dark:text-amber-400 border-amber-200 dark:border-amber-800');
                                            const height = isOwner ? 90 : 45;

                                            return (
                                                <div key={m.id} onContextMenu={(e) => handleContextMenu(e, m.id)} className="absolute flex flex-col items-center z-20 hover:z-30 transition-all hover:-translate-y-1 cursor-pointer" style={{ left: `calc(${percent}% - 2px)`, bottom: 'calc(100% - 128px - 4px)' }}>
                                                    <div className={`whitespace-nowrap text-xs mb-1 px-3 py-1.5 flex flex-col items-center rounded-lg border shadow-sm backdrop-blur-sm ${isOwner ? 'font-extrabold' : 'font-bold'} ${colorClass}`} style={m.color ? { backgroundColor: `${m.color}15`, borderColor: `${m.color}80`, color: m.color } : {}}>
                                                        <span>{m.name}</span>
                                                    </div>
                                                    <div className="text-[10px] font-semibold text-slate-500 dark:text-slate-400 mb-2 bg-white/90 dark:bg-slate-800/90 px-1.5 py-0.5 rounded shadow-sm border border-slate-100 dark:border-slate-700">{formatDayMonth(m.start)}</div>
                                                    <div className={`w-[2px] ${m.color ? '' : (isOwner ? 'bg-emerald-400 dark:bg-emerald-600' : 'bg-amber-300 dark:bg-amber-600')}`} style={m.color ? { height: `${height}px`, backgroundColor: `${m.color}80` } : { height: `${height}px` }} />
                                                    <div className={`w-3.5 h-3.5 rotate-45 border-[3px] border-white dark:border-slate-800 -mb-1.5 shadow-md ${m.color ? '' : (isOwner ? 'bg-emerald-500' : 'bg-amber-400')}`} style={m.color ? { backgroundColor: m.color } : {}} />
                                                </div>
                                            )
                                        })}

                                        {/* Timeline Items Bottom */}
                                        <div className="mt-8 relative w-full" style={{ height: `${timelineItems.totalHeight}px` }}>
                                            {timelineItems.items.map((item, i) => {
                                                if (item.type === 'phase') {
                                                    const phaseDur = diffDays(item.bounds.minS, item.bounds.maxE);
                                                    return (
                                                        <div key={`p-${item.phase}`} className="absolute h-6 rounded-md shadow-sm flex items-center px-3" style={{ left: `${item.left}%`, width: `${item.width}%`, top: `${item.y}px`, backgroundColor: phaseColors[item.phase] || '#94a3b8' }}>
                                                            <span className="absolute -top-4 left-0 text-[10px] font-bold text-slate-400 dark:text-slate-500 whitespace-nowrap">{formatDayMonth(item.bounds.minS)}</span>
                                                            <span className="text-[10px] font-bold text-white truncate drop-shadow-sm">{item.phase}</span>
                                                            {phaseDur > 21 && <span className="absolute -top-4 right-0 text-[10px] font-bold text-slate-400 dark:text-slate-500 whitespace-nowrap">{formatDayMonth(item.bounds.maxE)}</span>}
                                                        </div>
                                                    );
                                                } else if (item.type === 'task') {
                                                    return (
                                                        <div key={`t-${item.task.id}`} className="absolute h-4 rounded-sm shadow-sm flex items-center px-2 opacity-90" style={{ left: `${item.left}%`, width: `${item.width}%`, top: `${item.y}px`, backgroundColor: item.task.color || phaseColors[item.phase] || '#94a3b8' }}>
                                                            <span className="text-[9px] font-bold text-white truncate">{item.task.name}</span>
                                                        </div>
                                                    );
                                                }
                                                return null;
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* --- RENAME MODAL --- */}
                    {renameModal && (
                        <div className="fixed inset-0 bg-slate-900/40 dark:bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] p-4">
                            <form onSubmit={handleRenameSubmit} className="bg-white dark:bg-slate-800 rounded-xl shadow-2xl w-full max-w-sm overflow-hidden transform transition-all">
                                <div className="px-5 py-4 border-b border-slate-100 dark:border-slate-700 flex items-center justify-between">
                                    <h2 className="text-base font-bold text-slate-800 dark:text-white">Rename {renameModal.type === 'project' ? 'Project' : 'Version'}</h2>
                                    <button type="button" onClick={() => setRenameModal(null)} className="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200"><X className="w-4 h-4" /></button>
                                </div>
                                <div className="p-5 space-y-4">
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">Name</label>
                                        <input autoFocus type="text" value={renameModal.name} onChange={(e) => setRenameModal({ ...renameModal, name: e.target.value })} className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm font-medium focus:ring-2 focus:ring-indigo-500 text-slate-900 dark:text-slate-100" />
                                    </div>
                                    {renameModal.type === 'project' && (
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">Client Name (Optional)</label>
                                            <input type="text" value={renameModal.clientName || ''} onChange={(e) => setRenameModal({ ...renameModal, clientName: e.target.value })} placeholder="e.g. Acme Corp" className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm font-medium focus:ring-2 focus:ring-indigo-500 text-slate-900 dark:text-slate-100" />
                                        </div>
                                    )}
                                </div>
                                <div className="px-5 py-3 border-t border-slate-100 dark:border-slate-700 bg-slate-50 dark:bg-slate-800 flex justify-end space-x-2">
                                    <button type="button" onClick={() => setRenameModal(null)} className="px-3 py-1.5 text-sm font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-md">Cancel</button>
                                    <button type="submit" className="px-3 py-1.5 text-sm font-semibold text-white bg-indigo-600 hover:bg-indigo-700 rounded-md">Save</button>
                                </div>
                            </form>
                        </div>
                    )}

                    {/* --- SHIFT MODAL --- */}
                    {showShiftModal && (
                        <div className="fixed inset-0 bg-slate-900/40 dark:bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] p-4">
                            <form onSubmit={handleShiftSubmit} className="bg-white dark:bg-slate-800 rounded-xl shadow-2xl w-full max-w-sm overflow-hidden transform transition-all">
                                <div className="px-5 py-4 border-b border-slate-100 dark:border-slate-700 flex items-center justify-between">
                                    <h2 className="text-base font-bold text-slate-800 dark:text-white flex items-center"><CalendarDays className="w-5 h-5 mr-2 text-indigo-500" /> Shift Schedule</h2>
                                    <button type="button" onClick={() => setShowShiftModal(false)} className="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 p-1 rounded-full"><X className="w-4 h-4" /></button>
                                </div>
                                <div className="p-5 space-y-4">
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">Target Scope</label>
                                        <select value={shiftTarget} onChange={(e) => setShiftTarget(e.target.value)} className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm font-medium focus:ring-2 focus:ring-indigo-500 text-slate-900 dark:text-slate-100 transition-colors">
                                            <option value="All">Entire Project</option>
                                            {phases.map(p => <option key={p} value={p}>Phase: {p}</option>)}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">Shift Method</label>
                                        <div className="flex bg-slate-100 dark:bg-slate-900 p-1 rounded-lg border border-slate-200 dark:border-slate-700 shadow-inner">
                                            <button type="button" onClick={() => setShiftMode('days')} className={`flex-1 py-1.5 text-xs font-bold rounded-md transition-colors ${shiftMode === 'days' ? 'bg-white dark:bg-slate-700 text-indigo-600 dark:text-indigo-400 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300'}`}>By Days</button>
                                            <button type="button" onClick={() => {
                                                setShiftMode('date');
                                                // Pre-fill shift date with earliest date of target
                                                let earliestStr = null;
                                                tasks.forEach(t => {
                                                    if (shiftTarget === 'All' || t.phase === shiftTarget) {
                                                        if (!earliestStr || t.start < earliestStr) earliestStr = t.start;
                                                    }
                                                });
                                                if (earliestStr) setShiftDate(earliestStr);
                                            }} className={`flex-1 py-1.5 text-xs font-bold rounded-md transition-colors ${shiftMode === 'date' ? 'bg-white dark:bg-slate-700 text-indigo-600 dark:text-indigo-400 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300'}`}>To Specific Date</button>
                                        </div>
                                    </div>

                                    {shiftMode === 'days' ? (
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">Days to Shift</label>
                                            <input autoFocus type="number" value={shiftDays} onChange={(e) => setShiftDays(e.target.value)} placeholder="e.g. 14 or -7" className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm font-medium focus:ring-2 focus:ring-indigo-500 text-slate-900 dark:text-slate-100 transition-colors" />
                                            <p className="mt-2 text-[10px] text-slate-500 dark:text-slate-400 leading-tight">Positive numbers push the schedule out. Negative numbers pull it forward. Dependencies will be automatically adjusted.</p>
                                        </div>
                                    ) : (
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-1.5">New Start Date</label>
                                            <input autoFocus type="date" value={shiftDate} onChange={(e) => setShiftDate(e.target.value)} className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg px-3 py-2 text-sm font-medium focus:ring-2 focus:ring-indigo-500 text-slate-900 dark:text-slate-100 transition-colors" />
                                            <p className="mt-2 text-[10px] text-slate-500 dark:text-slate-400 leading-tight">Adjusts the earliest item in the {shiftTarget === 'All' ? 'project' : 'phase'} to this date and shifts everything else relative to it.</p>
                                        </div>
                                    )}
                                </div>
                                <div className="px-5 py-3 border-t border-slate-100 dark:border-slate-700 bg-slate-50 dark:bg-slate-800 flex justify-end space-x-2 transition-colors">
                                    <button type="button" onClick={() => setShowShiftModal(false)} className="px-3 py-1.5 text-sm font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-lg transition-colors">Cancel</button>
                                    <button type="submit" className="px-3 py-1.5 text-sm font-semibold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-sm transition-colors">Apply Shift</button>
                                </div>
                            </form>
                        </div>
                    )}

                    {/* --- EXPORT MODAL --- */}
                    {showExportModal && (
                        <div className="fixed inset-0 bg-slate-900/40 dark:bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                            <div className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-md overflow-hidden transform transition-all">
                                <div className="px-6 py-4 border-b border-slate-100 dark:border-slate-700 flex items-center justify-between bg-slate-50/50 dark:bg-slate-800/50">
                                    <h2 className="text-lg font-bold text-slate-800 dark:text-white flex items-center"><Download className="w-5 h-5 mr-2 text-indigo-500" /> Export Options</h2>
                                    <button onClick={() => setShowExportModal(false)} className="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 p-1 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors"><X className="w-5 h-5" /></button>
                                </div>

                                <div className="p-6 space-y-4">
                                    <button onClick={exportPDF} disabled={isExporting} className="w-full flex items-center justify-between px-4 py-3 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 text-slate-700 dark:text-slate-200 font-bold text-sm rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600 shadow-sm transition-all group disabled:opacity-50">
                                        <div className="flex items-center">
                                            {isExporting ? <Loader2 className="w-5 h-5 mr-3 text-indigo-500 animate-spin" /> : <FileText className="w-5 h-5 mr-3 text-slate-400 group-hover:text-indigo-500 transition-colors" />}
                                            {layoutView === 'Timeline' ? 'Timeline PDF (Vector)' : 'Gantt Chart PDF (Vector)'}
                                        </div>
                                        <ChevronRight className="w-4 h-4 opacity-50" />
                                    </button>

                                    <button onClick={exportExcelGantt} className="w-full flex items-center justify-between px-4 py-3 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 text-slate-700 dark:text-slate-200 font-bold text-sm rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600 shadow-sm transition-all group">
                                        <div className="flex items-center"><FileSpreadsheet className="w-5 h-5 mr-3 text-slate-400 group-hover:text-emerald-500 transition-colors" /> Excel (.xls) Gantt Data</div>
                                        <ChevronRight className="w-4 h-4 opacity-50" />
                                    </button>

                                    <button onClick={exportCSV} className="w-full flex items-center justify-between px-4 py-3 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 text-slate-700 dark:text-slate-200 font-bold text-sm rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600 shadow-sm transition-all group">
                                        <div className="flex items-center"><FileSpreadsheet className="w-5 h-5 mr-3 text-slate-400 group-hover:text-emerald-500 transition-colors" /> Simple CSV Data</div>
                                        <ChevronRight className="w-4 h-4 opacity-50" />
                                    </button>

                                    <button onClick={exportMilestoneICS} className="w-full flex items-center justify-between px-4 py-3 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 text-slate-700 dark:text-slate-200 font-bold text-sm rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600 shadow-sm transition-all group">
                                        <div className="flex items-center"><Calendar className="w-5 h-5 mr-3 text-slate-400 group-hover:text-amber-500 transition-colors" /> Export Milestones to Outlook (.ics)</div>
                                        <ChevronRight className="w-4 h-4 opacity-50" />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- VIEW SETTINGS MODAL --- */}
                    {showViewModal && (
                        <div className="fixed inset-0 bg-slate-900/40 dark:bg-black/60 backdrop-blur-sm flex items-center justify-center z-[60] p-4">
                            <div className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-md overflow-hidden transform transition-all">
                                <div className="px-6 py-4 border-b border-slate-100 dark:border-slate-700 flex items-center justify-between bg-slate-50/50 dark:bg-slate-800/50">
                                    <h2 className="text-lg font-bold text-slate-800 dark:text-white flex items-center"><Eye className="w-5 h-5 mr-2 text-indigo-500" /> View Settings</h2>
                                    <button onClick={() => setShowViewModal(false)} className="text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 p-1 rounded-full hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors"><X className="w-5 h-5" /></button>
                                </div>

                                <div className="p-6 space-y-6">
                                    {/* Row Height */}
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-2">Row Height</label>
                                        <div className="flex items-center space-x-3">
                                            <span className="text-xs font-semibold text-slate-400 w-6">22</span>
                                            <input type="range" min="22" max="44" value={rowHeight} onChange={(e) => setRowHeight(parseInt(e.target.value))} className="flex-1 accent-indigo-500 h-2 rounded-full cursor-pointer" />
                                            <span className="text-xs font-semibold text-slate-400 w-6">44</span>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 text-xs font-bold px-2.5 py-1 rounded-md min-w-[42px] text-center">{rowHeight}px</div>
                                        </div>
                                    </div>

                                    {/* Text Size */}
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-2">Text Size</label>
                                        <div className="flex items-center space-x-3">
                                            <span className="text-xs font-semibold text-slate-400 w-6">10</span>
                                            <input type="range" min="10" max="16" value={textSize} onChange={(e) => setTextSize(parseInt(e.target.value))} className="flex-1 accent-indigo-500 h-2 rounded-full cursor-pointer" />
                                            <span className="text-xs font-semibold text-slate-400 w-6">16</span>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 text-xs font-bold px-2.5 py-1 rounded-md min-w-[42px] text-center">{textSize}px</div>
                                        </div>
                                    </div>

                                    {/* Column Visibility */}
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-2">Column Visibility</label>
                                        <div className="grid grid-cols-2 gap-2">
                                            {[
                                                { key: 'party', label: 'Party' },
                                                { key: 'duration', label: 'Duration' },
                                                { key: 'start', label: 'Start Date' },
                                                { key: 'end', label: 'End Date' }
                                            ].map(col => (
                                                <button key={col.key} onClick={() => setColumnVisibility(prev => ({ ...prev, [col.key]: !prev[col.key] }))}
                                                    className={`flex items-center justify-between px-3 py-2 rounded-lg text-xs font-bold transition-all border shadow-sm ${columnVisibility[col.key] ? 'bg-indigo-50 dark:bg-indigo-900/30 border-indigo-200 dark:border-indigo-800 text-indigo-700 dark:text-indigo-300' : 'bg-slate-50 dark:bg-slate-700 border-slate-200 dark:border-slate-600 text-slate-400 dark:text-slate-500'}`}>
                                                    <span>{col.label}</span>
                                                    {columnVisibility[col.key] ? <Eye className="w-3.5 h-3.5" /> : <X className="w-3.5 h-3.5" />}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    {/* PDF Paper Size */}
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-2">PDF Paper Size</label>
                                        <div className="flex bg-slate-100 dark:bg-slate-900 p-1 rounded-lg border border-slate-200 dark:border-slate-700 shadow-inner">
                                            <button onClick={() => setPdfPaperSize('letter')} className={`flex-1 py-2 text-xs font-bold rounded-md transition-all ${pdfPaperSize === 'letter' ? 'bg-white dark:bg-slate-700 text-indigo-600 dark:text-indigo-400 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300'}`}>
                                                Letter <span className="text-[10px] font-normal opacity-60">(8.511")</span>
                                            </button>
                                            <button onClick={() => setPdfPaperSize('tabloid')} className={`flex-1 py-2 text-xs font-bold rounded-md transition-all ${pdfPaperSize === 'tabloid' ? 'bg-white dark:bg-slate-700 text-indigo-600 dark:text-indigo-400 shadow-sm' : 'text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300'}`}>
                                                Tabloid <span className="text-[10px] font-normal opacity-60">(1117")</span>
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <div className="px-6 py-3 border-t border-slate-100 dark:border-slate-700 bg-slate-50 dark:bg-slate-800 flex justify-end">
                                    <button onClick={() => setShowViewModal(false)} className="px-4 py-1.5 text-sm font-semibold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-sm transition-colors">Done</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- CONTEXT MENU --- */}
                    {contextMenu && (
                        <div className="fixed bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 shadow-xl rounded-md py-1 z-[60] text-sm min-w-[180px]" style={{ left: contextMenu.x, top: contextMenu.y }} onClick={(e) => e.stopPropagation()}>
                            <button onClick={() => { colorTargetRef.current = contextMenu.taskId; if (colorInputRef.current) { colorInputRef.current.value = tasks.find(t => t.id === contextMenu.taskId)?.color || phaseColors[tasks.find(t => t.id === contextMenu.taskId)?.phase] || '#94a3b8'; colorInputRef.current.style.left = contextMenu.x + 'px'; colorInputRef.current.style.top = contextMenu.y + 'px'; colorInputRef.current.click(); } setContextMenu(null); }} className="w-full text-left px-4 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-700 dark:text-slate-300 font-semibold flex items-center cursor-pointer">
                                <div className="w-4 h-4 rounded-full border border-slate-300 dark:border-slate-600 mr-2 shadow-inner flex-shrink-0" style={{ backgroundColor: tasks.find(t => t.id === contextMenu.taskId)?.color || phaseColors[tasks.find(t => t.id === contextMenu.taskId)?.phase] || '#94a3b8' }} />
                                Bar Color
                            </button>
                            {tasks.find(t => t.id === contextMenu.taskId)?.color && (
                                <button onClick={() => { handleTaskChange(contextMenu.taskId, 'color', null); setContextMenu(null); }} className="w-full text-left px-4 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-500 dark:text-slate-400 font-semibold flex items-center cursor-pointer text-xs">
                                    <X className="w-3.5 h-3.5 mr-2" /> Reset Bar Color
                                </button>
                            )}
                            <button onClick={() => { cycleMilestone(contextMenu.taskId); setContextMenu(null); }} className="w-full text-left px-4 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-slate-700 dark:text-slate-300 font-semibold flex items-center">
                                <Flag className="w-4 h-4 mr-2 text-indigo-500" /> Toggle Milestone
                            </button>
                            <button onClick={() => { deleteTask(contextMenu.taskId); setContextMenu(null); }} className="w-full text-left px-4 py-2 hover:bg-rose-50 dark:hover:bg-rose-900/30 text-rose-600 dark:text-rose-400 font-semibold flex items-center transition-colors">
                                <Trash2 className="w-4 h-4 mr-2" /> Delete Task
                            </button>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
